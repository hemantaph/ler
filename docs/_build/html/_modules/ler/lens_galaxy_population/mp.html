

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ler.lens_galaxy_population.mp &mdash; ler 0.4.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/scalefix.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=776609e1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/dark_mode_css/general.css?v=c0a7eb24" />
      <link rel="stylesheet" type="text/css" href="../../../_static/dark_mode_css/dark.css?v=70edf1c7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5bfaad31"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="../../../_static/dark_mode_js/default_light.js?v=c2e647ce"></script>
      <script src="../../../_static/dark_mode_js/theme_switcher.js?v=358d3910"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980b9" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ler
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Summary.html">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../code_overview.html">Code overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GW_events.html">Gravitational wave event rates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GW_equations.html">Gravitational wave events sampling (Analytical formulation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Lensed_events.html">Lensed event rates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Lensed_equations.html">Lensed event sampling (Analytical formulation)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/rates/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.rates</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/gw_source_population/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.gw_source_population</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/lens_galaxy_population/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.lens_galaxy_population</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/image_properties/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.image_properties</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/utils/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.utils</span></code></a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980b9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ler</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ler.lens_galaxy_population.mp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ler.lens_galaxy_population.mp</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">njit</span><span class="p">,</span> <span class="n">prange</span>
<span class="kn">from</span> <span class="nn">lenstronomy.LensModel.Solver.epl_shear_solver</span> <span class="kn">import</span> <span class="n">caustics_epl_shear</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Polygon</span>

<span class="kn">from</span> <span class="nn">.jit_functions</span> <span class="kn">import</span> <span class="n">phi_cut_SIE</span><span class="p">,</span> <span class="n">phi_q2_ellipticity_hemanta</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">inverse_transform_sampler</span><span class="p">,</span> <span class="n">cubic_spline_interpolator</span><span class="p">,</span> <span class="n">cubic_spline_interpolator2d_array</span><span class="p">,</span> <span class="n">inverse_transform_sampler2d</span><span class="p">,</span> <span class="n">load_json</span>

<span class="kn">from</span> <span class="nn">.cross_section_interpolator</span> <span class="kn">import</span> <span class="n">make_cross_section_reinit</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<div class="viewcode-block" id="lens_redshift_strongly_lensed_njit">
<a class="viewcode-back" href="../../../autoapi/ler/lens_galaxy_population/mp/index.html#ler.lens_galaxy_population.lens_redshift_strongly_lensed_njit">[docs]</a>
<span class="k">def</span> <span class="nf">lens_redshift_strongly_lensed_njit</span><span class="p">(</span>
        <span class="n">zs_array</span><span class="p">,</span> <span class="c1"># 1D</span>
        <span class="n">zl_scaled</span><span class="p">,</span> <span class="c1"># 2D</span>
        <span class="n">sigma_min</span><span class="p">,</span>
        <span class="n">sigma_max</span><span class="p">,</span>
        <span class="n">q_rvs</span><span class="p">,</span>
        <span class="n">phi_rvs</span><span class="p">,</span>
        <span class="n">gamma_rvs</span><span class="p">,</span>
        <span class="n">shear_rvs</span><span class="p">,</span>
        <span class="n">number_density</span><span class="p">,</span>
        <span class="n">cross_section</span><span class="p">,</span>
        <span class="n">dVcdz_function</span><span class="p">,</span>
        <span class="n">integration_size</span><span class="p">,</span>
    <span class="p">):</span>

    <span class="n">size_zs</span> <span class="o">=</span> <span class="n">zs_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">size_zl</span> <span class="o">=</span> <span class="n">zl_scaled</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">result_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">size_zs</span><span class="p">,</span> <span class="n">size_zl</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">size_zs</span><span class="p">):</span>

        <span class="c1"># redshift of the lens between the source and the observer</span>
        <span class="n">zl_array</span> <span class="o">=</span> <span class="n">zl_scaled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">zs_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># 1D array, unscaled</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size_zl</span><span class="p">):</span>

            <span class="c1"># monte carlo integration </span>
            <span class="n">zs_</span> <span class="o">=</span> <span class="n">zs_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">integration_size</span><span class="p">)</span>
            <span class="n">zl</span> <span class="o">=</span> <span class="n">zl_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">zl_</span> <span class="o">=</span> <span class="n">zl</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">integration_size</span><span class="p">)</span>

            <span class="c1"># velocity dispersion distribution</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">sigma_min</span><span class="p">,</span> <span class="n">sigma_max</span><span class="p">,</span> <span class="n">integration_size</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">q_rvs</span><span class="p">(</span><span class="n">integration_size</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">phi_rvs</span><span class="p">(</span><span class="n">integration_size</span><span class="p">)</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma_rvs</span><span class="p">(</span><span class="n">integration_size</span><span class="p">)</span>
            <span class="n">gamma1</span><span class="p">,</span> <span class="n">gamma2</span> <span class="o">=</span> <span class="n">shear_rvs</span><span class="p">(</span><span class="n">integration_size</span><span class="p">)</span>
            
            <span class="n">area_array</span> <span class="o">=</span> <span class="n">cross_section</span><span class="p">(</span>
                <span class="n">zs_</span><span class="p">,</span> <span class="n">zl_</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">gamma1</span><span class="p">,</span> <span class="n">gamma2</span>
            <span class="p">)</span>


            <span class="c1"># # this is to avoid nan, inf, -inf</span>
            <span class="c1"># # idx = (area_array&gt;=2.4906932608826035e-28) &amp; (area_array&lt;=1.972789211435565e-08)</span>
            <span class="c1"># idx = np.logical_not(np.isinf(area_array))</span>
            <span class="c1"># idx &amp;= (area_array&gt;0)</span>
            <span class="c1"># # idx = np.logical_not(np.isnan(area_array))</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">area_array</span><span class="p">))</span>
            <span class="n">idx</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">area_array</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="k">continue</span>

            <span class="n">phi_sigma</span> <span class="o">=</span> <span class="n">number_density</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">zl_</span><span class="p">)</span>
                
            <span class="c1"># diffrential co-moving volume </span>
            <span class="n">dVcdz</span> <span class="o">=</span> <span class="n">dVcdz_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">zl</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># print(&#39;dVcdz: &#39;, dVcdz)</span>

            <span class="c1"># cross-section</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_max</span><span class="o">-</span><span class="n">sigma_min</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span> <span class="n">area_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">phi_sigma</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">dVcdz</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="n">result_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>

            <span class="c1"># if (zs_array[i]==0.001) and (zl_array[j]==0.0001):</span>
            <span class="c1">#     print(&#39;zs: &#39;, zs_array[i])</span>
            <span class="c1">#     print(&#39;zl: &#39;, zl_array[j])</span>
            <span class="c1">#     print(f&#39;sigma: {sigma}&#39;)</span>
            <span class="c1">#     print(f&#39;q: {q}&#39;)</span>
            <span class="c1">#     print(&#39;area_array: &#39;, area_array)</span>
            <span class="c1">#     print(&#39;phi_sigma: &#39;, phi_sigma)</span>
            <span class="c1">#     print(&#39;dVcdz: &#39;, dVcdz)</span>
            <span class="c1">#     print(&#39;result: &#39;, result)</span>
        
    <span class="k">return</span><span class="p">(</span><span class="n">result_array</span><span class="p">)</span></div>


<div class="viewcode-block" id="lens_redshift_strongly_lensed_mp">
<a class="viewcode-back" href="../../../autoapi/ler/lens_galaxy_population/mp/index.html#ler.lens_galaxy_population.lens_redshift_strongly_lensed_mp">[docs]</a>
<span class="k">def</span> <span class="nf">lens_redshift_strongly_lensed_mp</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span>  <span class="c1"># integration size</span>
    <span class="n">zs</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># float</span>
    <span class="c1"># angular diameter distance</span>
    <span class="n">Da_zs</span> <span class="o">=</span> <span class="n">cubic_spline_interpolator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">zs</span><span class="p">]),</span> <span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># float</span>

    <span class="c1"># redshift of the lens between the source and the observer</span>
    <span class="n">zl_array</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">zs</span> <span class="c1"># 1D array, unscaled</span>

    <span class="c1"># initialize interpolator</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cross_section_epl_shear_interpolation&#39;</span><span class="p">:</span>
        <span class="n">cs_grid</span><span class="p">,</span> <span class="n">cs_csunit_slope</span><span class="p">,</span> <span class="n">cs_csunit_intercept</span><span class="p">,</span> <span class="n">e1_grid</span><span class="p">,</span> <span class="n">e2_grid</span><span class="p">,</span> <span class="n">gamma_grid</span><span class="p">,</span> <span class="n">gamma1_grid</span><span class="p">,</span> <span class="n">gamma2_grid</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Create the interpolator instance</span>
        <span class="n">cs_caculator</span> <span class="o">=</span> <span class="n">make_cross_section_reinit</span><span class="p">(</span>
            <span class="n">e1_grid</span><span class="o">=</span><span class="n">e1_grid</span><span class="p">,</span> 
            <span class="n">e2_grid</span><span class="o">=</span><span class="n">e2_grid</span><span class="p">,</span> 
            <span class="n">gamma_grid</span><span class="o">=</span><span class="n">gamma_grid</span><span class="p">,</span> 
            <span class="n">gamma1_grid</span><span class="o">=</span><span class="n">gamma1_grid</span><span class="p">,</span> 
            <span class="n">gamma2_grid</span><span class="o">=</span><span class="n">gamma2_grid</span><span class="p">,</span> 
            <span class="n">cs_grid</span><span class="o">=</span><span class="n">cs_grid</span><span class="p">,</span>
            <span class="n">slope</span><span class="o">=</span><span class="mf">0.31830988618379075</span><span class="p">,</span>
            <span class="n">intercept</span><span class="o">=-</span><span class="mf">3.2311742677852644e-27</span>
        <span class="p">)</span>

    <span class="n">result_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">zl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zl_array</span><span class="p">):</span>
        <span class="c1"># monte carlo integration </span>
        <span class="c1"># (sigma_max-sigma_min)*np.average( area_array[idx] * phi_sigma[idx] * dVcdz )/(4*np.pi)</span>
        <span class="c1"># normalization factor (sigma_max-sigma_min)/(4*np.pi)</span>
        <span class="c1"># cross-section part: area_array[idx]</span>
        <span class="c1"># number density part: phi_sigma[idx]</span>
        <span class="c1"># zs is fixed for the entire function call</span>
        <span class="c1"># zl is fixed for each iteration of the for loop</span>

        <span class="c1"># velocity dispersion distribution</span>
        <span class="n">sigma_min</span><span class="p">,</span> <span class="n">sigma_max</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> 
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">sigma_min</span><span class="p">,</span> <span class="n">sigma_max</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

        <span class="c1">## Einstein radius calculation</span>
        <span class="c1"># angular diameter distance</span>
        <span class="n">Da_zl</span> <span class="o">=</span> <span class="n">cubic_spline_interpolator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">zl</span><span class="p">]),</span> <span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Dls</span> <span class="o">=</span> <span class="p">(</span><span class="n">Da_zs</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">zs</span><span class="p">)</span> <span class="o">-</span> <span class="n">Da_zl</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">zl</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">zs</span><span class="p">)</span>

        <span class="c1"># einstein radius</span>
        <span class="n">theta_E</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">4.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">sigma</span> <span class="o">/</span> <span class="mf">299792.458</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Dls</span> <span class="o">/</span> <span class="n">Da_zs</span>
        <span class="p">)</span>  <span class="c1"># Note: km/s for sigma; Dls, Ds are in Mpc</span>

        <span class="c1">#######</span>
        <span class="c1"># SIS #</span>
        <span class="c1">#######</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cross_section_sis&#39;</span><span class="p">:</span>
            <span class="c1"># # print(&#39;\nUsing SIS cross-section&#39;)</span>
            <span class="n">area_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">theta_E</span><span class="o">**</span><span class="mi">2</span>

            <span class="c1"># # print(&#39;area_array: &#39;, area_array)</span>

        <span class="k">else</span><span class="p">:</span> 
            <span class="c1"># axis ratio distribution</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;axis_ratio_uniform&#39;</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="n">inverse_transform_sampler2d</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">q</span> <span class="o">=</span> <span class="n">inverse_transform_sampler</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
            
            <span class="c1">#######</span>
            <span class="c1"># SIE #</span>
            <span class="c1">#######</span>
            <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cross_section_sie_feixu&#39;</span><span class="p">:</span>
                <span class="n">area_array</span> <span class="o">=</span> <span class="n">phi_cut_SIE</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">theta_E</span><span class="o">**</span><span class="mi">2</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># axis rotation angle</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;axis_rotation_angle_uniform&#39;</span><span class="p">:</span>
                    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phi</span> <span class="o">=</span> <span class="n">inverse_transform_sampler</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

                <span class="c1"># Transform the axis ratio and the axis rotation angle, to ellipticities e1, e2, using lenstronomy</span>
                <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="o">=</span> <span class="n">phi_q2_ellipticity_hemanta</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span>

                <span class="c1"># Sample shears</span>
                <span class="c1"># gamma1, gamma2 = np.random.normal(loc=params[9][0], scale=params[9][1], size=(2,size))</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;external_shear_normal&#39;</span><span class="p">:</span>
                    <span class="n">gamma1</span><span class="p">,</span> <span class="n">gamma2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">size</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;params[9][0], for gamma1 and gamma2, is not recognized. Only external_shear_normal is implemented.&#39;</span><span class="p">)</span>


                <span class="c1"># Sample the density profile slop of the mass density distribution</span>
                <span class="c1"># gamma = np.random.normal(loc=params[10][0], scale=params[10][1], size=size)</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;density_profile_slope_normal&#39;</span><span class="p">:</span>
                    <span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gamma</span> <span class="o">=</span> <span class="n">inverse_transform_sampler</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

                <span class="c1">#############</span>
                <span class="c1"># EPL+Shear #</span>
                <span class="c1">#############</span>
                <span class="c1"># cross-section</span>
                <span class="c1"># option 1: use nearest-neighbor interpolation (fast)</span>
                <span class="c1"># option 2: direct cross-section calculation with lenstronomy</span>
                <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cross_section_epl_shear_interpolation&#39;</span><span class="p">:</span>
                    <span class="n">area_array</span> <span class="o">=</span> <span class="n">cs_caculator</span><span class="p">(</span><span class="n">theta_E</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">gamma1</span><span class="p">,</span> <span class="n">gamma2</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;cross_section_epl_shear_numerical&#39;</span><span class="p">:</span>
                    <span class="n">area_array</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
                        <span class="n">area_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cross_section</span><span class="p">(</span><span class="n">theta_E</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">e1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">e2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gamma</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gamma1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gamma2</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="n">area_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">area_array</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;params[7][0] not recognized. Should be cross_section_epl_shear_interpolation, cross_section_epl_shear_numerical, cross_section_sis, or cross_section_sie_feixu.&#39;</span><span class="p">))</span>

        <span class="c1"># # this is to avoid nan, inf, -inf</span>
        <span class="c1"># # idx = (area_array&gt;=2.4906932608826035e-28) &amp; (area_array&lt;=1.972789211435565e-08)</span>
        <span class="c1"># idx = np.logical_not(np.isinf(area_array))</span>
        <span class="c1"># idx &amp;= (area_array&gt;0)</span>
        <span class="c1"># # idx = np.logical_not(np.isnan(area_array))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">area_array</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">area_array</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># velocity dispersion distribution</span>
        <span class="n">zl_</span> <span class="o">=</span> <span class="n">zl</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">phi_sigma</span> <span class="o">=</span> <span class="n">cubic_spline_interpolator</span><span class="p">(</span>
                <span class="n">sigma</span><span class="p">,</span>
                <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span>
                <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            <span class="p">)</span>   
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi_sigma</span> <span class="o">=</span> <span class="n">cubic_spline_interpolator2d_array</span><span class="p">(</span>
                <span class="n">sigma</span><span class="p">,</span> 
                <span class="n">zl_</span><span class="p">,</span>
                <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span>
                <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
            <span class="p">)</span>
            
        <span class="c1"># diffrential co-moving volume </span>
        <span class="n">dVcdz</span> <span class="o">=</span> <span class="n">cubic_spline_interpolator</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">zl</span><span class="p">]),</span> <span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># cross-section</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">sigma_max</span><span class="o">-</span><span class="n">sigma_min</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span> <span class="n">area_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">phi_sigma</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">dVcdz</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">result_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">zs</span><span class="o">==</span><span class="mf">0.001</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">zl</span><span class="o">==</span><span class="mf">0.0001</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;zs: &#39;</span><span class="p">,</span> <span class="n">zs</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;zl: &#39;</span><span class="p">,</span> <span class="n">zl</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sigma: </span><span class="si">{</span><span class="n">sigma</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;q: </span><span class="si">{</span><span class="n">q</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;area_array: &#39;</span><span class="p">,</span> <span class="n">area_array</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;phi_sigma: &#39;</span><span class="p">,</span> <span class="n">phi_sigma</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;dVcdz: &#39;</span><span class="p">,</span> <span class="n">dVcdz</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;result: &#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;theta_E: &#39;</span><span class="p">,</span> <span class="n">theta_E</span><span class="p">)</span>
    
    <span class="k">return</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result_array</span><span class="p">))</span></div>


<span class="c1"># def lens_redshift_strongly_lensed_mp(params):</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     input_params = np.array(</span>
<span class="c1">#         [</span>
<span class="c1">#             zs,</span>
<span class="c1">#             zl_scaled,</span>
<span class="c1">#             sigma_args,</span>
<span class="c1">#             q_args,</span>
<span class="c1">#             Da_args,</span>
<span class="c1">#             dVcdz_args,</span>
<span class="c1">#             idx,</span>
<span class="c1">#             cs_args,</span>
<span class="c1">#             phi_args,</span>
<span class="c1">#             shear_args,</span>
<span class="c1">#             slope_args,</span>
<span class="c1">#             integration_size,</span>
<span class="c1">#         ],</span>
<span class="c1">#         dtype=object,</span>
<span class="c1">#     )</span>
<span class="c1">#     &quot;&quot;&quot;</span>

<span class="c1">#     size = params[11]  # integration size</span>
<span class="c1">#     zs = params[0] # float</span>
<span class="c1">#     # angular diameter distance</span>
<span class="c1">#     Da_function = njit(lambda z: cubic_spline_interpolator(z, params[4][0], params[4][1]))</span>
<span class="c1">#     Da_zs = Da_function(np.array([zs]))[0]</span>

<span class="c1">#     # redshift of the lens between the source and the observer</span>
<span class="c1">#     zl_array = params[1]*zs # 1D array, unscaled</span>

<span class="c1">#     # initialize interpolator</span>
<span class="c1">#     if params[7][0] == &#39;cross_section_epl_shear_interpolation&#39;:</span>
<span class="c1">#         (</span>
<span class="c1">#             e1_grid,</span>
<span class="c1">#             e2_grid,</span>
<span class="c1">#             gamma_grid,</span>
<span class="c1">#             gamma1_grid,</span>
<span class="c1">#             gamma2_grid,</span>
<span class="c1">#             cs_spline_coeff_grid,</span>
<span class="c1">#             _, # cs_csunit_slope</span>
<span class="c1">#             _, # cs_csunit_intercept</span>
<span class="c1">#         ) = load_json(params[7][1])</span>

<span class="c1">#         # Create the interpolator instance</span>
<span class="c1">#         cs_caculator = make_cross_section_reinit(</span>
<span class="c1">#             e1_grid=e1_grid, </span>
<span class="c1">#             e2_grid=e2_grid, </span>
<span class="c1">#             gamma_grid=gamma_grid, </span>
<span class="c1">#             gamma1_grid=gamma1_grid, </span>
<span class="c1">#             gamma2_grid=gamma2_grid, </span>
<span class="c1">#             cs_spline_coeff_grid=cs_spline_coeff_grid,</span>
<span class="c1">#             slope=0.31830988618379075,</span>
<span class="c1">#             intercept=-3.2311742677852644e-27</span>
<span class="c1">#         )</span>

<span class="c1">#     result_array = []</span>
<span class="c1">#     for i, zl in enumerate(zl_array):</span>
<span class="c1">#         # monte carlo integration </span>
<span class="c1">#         # (sigma_max-sigma_min)*np.average( area_array[idx] * phi_sigma[idx] * dVcdz )/(4*np.pi)</span>
<span class="c1">#         # normalization factor (sigma_max-sigma_min)/(4*np.pi)</span>
<span class="c1">#         # cross-section part: area_array[idx]</span>
<span class="c1">#         # number density part: phi_sigma[idx]</span>
<span class="c1">#         # zs is fixed for the entire function call</span>
<span class="c1">#         # zl is fixed for each iteration of the for loop</span>

<span class="c1">#         # velocity dispersion distribution</span>
<span class="c1">#         sigma_min, sigma_max = params[2][0], params[2][1] </span>
<span class="c1">#         sigma = np.random.uniform(sigma_min, sigma_max, size)</span>

<span class="c1">#         # print(&#39;sigma: &#39;, sigma)</span>

<span class="c1">#         #######</span>
<span class="c1">#         # SIS #</span>
<span class="c1">#         #######</span>
<span class="c1">#         if params[7][0] == &#39;cross_section_sis&#39;:</span>
<span class="c1">#             # # print(&#39;\nUsing SIS cross-section&#39;)</span>
<span class="c1">#             area_array = np.pi*theta_E**2</span>

<span class="c1">#             # # print(&#39;area_array: &#39;, area_array)</span>

<span class="c1">#         else: </span>
<span class="c1">#             # axis ratio distribution</span>
<span class="c1">#             if params[3][0] == &#39;axis_ratio_uniform&#39;:</span>
<span class="c1">#                 q = np.random.uniform(params[3][1], params[3][2], size)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 if params[3][3] is not None:</span>
<span class="c1">#                     q = inverse_transform_sampler2d(size, sigma, params[3][1], params[3][2], params[3][3])</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     q = inverse_transform_sampler(size, params[3][1], params[3][2])</span>
            
<span class="c1">#             #######</span>
<span class="c1">#             # SIE #</span>
<span class="c1">#             #######</span>
<span class="c1">#             if params[7][0] == &#39;cross_section_sie_feixu&#39;:</span>
<span class="c1">#                 area_array = phi_cut_SIE(q) * np.pi*theta_E**2</span>

<span class="c1">#             else:</span>
<span class="c1">#                 # axis rotation angle</span>
<span class="c1">#                 if params[8][0] == &#39;axis_rotation_angle_uniform&#39;:</span>
<span class="c1">#                     phi = np.random.uniform(params[8][1], params[8][2], size)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     phi = inverse_transform_sampler(size, params[8][1], params[8][2])</span>

<span class="c1">#                 # Transform the axis ratio and the axis rotation angle, to ellipticities e1, e2, using lenstronomy</span>
<span class="c1">#                 e1, e2 = phi_q2_ellipticity_hemanta(phi, q)</span>

<span class="c1">#                 # Sample shears</span>
<span class="c1">#                 # gamma1, gamma2 = np.random.normal(loc=params[9][0], scale=params[9][1], size=(2,size))</span>
<span class="c1">#                 if params[9][0] == &#39;external_shear_normal&#39;:</span>
<span class="c1">#                     gamma1, gamma2 = np.random.normal(loc=params[9][1], scale=params[9][2], size=(2,size))</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     raise ValueError(&#39;params[9][0], for gamma1 and gamma2, is not recognized. Only external_shear_normal is implemented.&#39;)</span>


<span class="c1">#                 # Sample the density profile slop of the mass density distribution</span>
<span class="c1">#                 # gamma = np.random.normal(loc=params[10][0], scale=params[10][1], size=size)</span>
<span class="c1">#                 if params[10][0] == &#39;density_profile_slope_normal&#39;:</span>
<span class="c1">#                     gamma = np.random.normal(loc=params[10][1], scale=params[10][2], size=size)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     gamma = inverse_transform_sampler(size, params[10][1], params[10][2])</span>

<span class="c1">#                 #############</span>
<span class="c1">#                 # EPL+Shear #</span>
<span class="c1">#                 #############</span>
<span class="c1">#                 # cross-section</span>
<span class="c1">#                 if params[7][0] == &#39;cross_section_epl_shear_interpolation&#39;:</span>
<span class="c1">#                     area_array = cs_caculator(theta_E, q, phi, gamma, gamma1, gamma2)</span>






<span class="c1">#                 elif params[7][0] == &#39;cross_section_epl_shear_numerical&#39;:</span>

<span class="c1">#                     area_array = []</span>
<span class="c1">#                     for i in range(size):</span>
<span class="c1">#                         area_array.append(cross_section(theta_E[i], e1[i], e2[i], gamma[i], gamma1[i], gamma2[i]))</span>
<span class="c1">#                     area_array = np.array(area_array)</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     raise(ValueError(&#39;params[7][0] not recognized. Should be cross_section_epl_shear_interpolation, cross_section_epl_shear_numerical, cross_section_sis, or cross_section_sie_feixu.&#39;))</span>

<span class="c1">#         # # this is to avoid nan, inf, -inf</span>
<span class="c1">#         # # idx = (area_array&gt;=2.4906932608826035e-28) &amp; (area_array&lt;=1.972789211435565e-08)</span>
<span class="c1">#         # idx = np.logical_not(np.isinf(area_array))</span>
<span class="c1">#         # idx &amp;= (area_array&gt;0)</span>
<span class="c1">#         # # idx = np.logical_not(np.isnan(area_array))</span>
<span class="c1">#         idx = np.logical_not(np.isinf(area_array))</span>
<span class="c1">#         idx &amp;= (area_array&gt;0)</span>
<span class="c1">#         if idx.sum() == 0:</span>
<span class="c1">#             result_array.append(0.)</span>
<span class="c1">#             continue</span>

<span class="c1">#         # velocity dispersion distribution</span>
<span class="c1">#         zl_ = zl*np.ones(size)</span>
<span class="c1">#         if params[2][3] is None:</span>
<span class="c1">#             phi_sigma = cubic_spline_interpolator(</span>
<span class="c1">#                 sigma,</span>
<span class="c1">#                 params[2][4],</span>
<span class="c1">#                 params[2][2]</span>
<span class="c1">#             )   </span>
<span class="c1">#         else:</span>
<span class="c1">#             phi_sigma = cubic_spline_interpolator2d_array(</span>
<span class="c1">#                 sigma, </span>
<span class="c1">#                 zl_,</span>
<span class="c1">#                 params[2][4],</span>
<span class="c1">#                 params[2][2],</span>
<span class="c1">#                 params[2][3]</span>
<span class="c1">#             )</span>

<span class="c1">#         # print(&#39;phi_sigma: &#39;, phi_sigma[idx])</span>
            
<span class="c1">#         # diffrential co-moving volume </span>
<span class="c1">#         dVcdz = cubic_spline_interpolator(np.array([zl]), params[5][0], params[5][1])[0]</span>

<span class="c1">#         # print(&#39;dVcdz: &#39;, dVcdz)</span>

<span class="c1">#         # cross-section</span>
<span class="c1">#         result = (sigma_max-sigma_min)*np.average( area_array[idx] * phi_sigma[idx] * dVcdz )/(4*np.pi)</span>
<span class="c1">#         result_array.append(result)</span>

<span class="c1">#         # print(&#39;result: &#39;, result)</span>
    
<span class="c1">#     return(params[6], np.array(result_array))</span>

<div class="viewcode-block" id="cross_section_unit_mp">
<a class="viewcode-back" href="../../../autoapi/ler/lens_galaxy_population/mp/index.html#ler.lens_galaxy_population.cross_section_unit_mp">[docs]</a>
<span class="k">def</span> <span class="nf">cross_section_unit_mp</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>

    <span class="n">kwargs_lens</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">&quot;theta_E&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
            <span class="s2">&quot;e1&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s2">&quot;e2&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s2">&quot;center_x&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="s2">&quot;center_y&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s2">&quot;gamma1&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
            <span class="s2">&quot;gamma2&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
            <span class="s2">&quot;ra_0&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;dec_0&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">]</span>

    <span class="n">caustic_double_points</span> <span class="o">=</span> <span class="n">caustics_epl_shear</span><span class="p">(</span>
        <span class="n">kwargs_lens</span><span class="p">,</span> <span class="n">return_which</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">maginf</span><span class="o">=-</span><span class="mi">100</span>
    <span class="p">)</span>
    <span class="n">caustic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">caustic_double_points</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>

    <span class="c1"># If there is a nan, caustic=False, draw a new gamma</span>
    <span class="k">if</span> <span class="n">caustic</span><span class="p">:</span>
        <span class="n">area_</span> <span class="o">=</span> <span class="p">(</span><span class="n">Polygon</span><span class="p">(</span><span class="n">caustic_double_points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">area_</span> <span class="o">=</span> <span class="mf">0.0</span>
        
    <span class="k">return</span> <span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">area_</span></div>


<div class="viewcode-block" id="cross_section_mp">
<a class="viewcode-back" href="../../../autoapi/ler/lens_galaxy_population/mp/index.html#ler.lens_galaxy_population.cross_section_mp">[docs]</a>
<span class="k">def</span> <span class="nf">cross_section_mp</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>

    <span class="n">theta_E</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">e1</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">gamma1</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">gamma2</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>

    <span class="n">kwargs_lens</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">&quot;theta_E&quot;</span><span class="p">:</span> <span class="n">theta_E</span><span class="p">,</span>
            <span class="s2">&quot;e1&quot;</span><span class="p">:</span> <span class="n">e1</span><span class="p">,</span>
            <span class="s2">&quot;e2&quot;</span><span class="p">:</span> <span class="n">e2</span><span class="p">,</span>
            <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
            <span class="s2">&quot;center_x&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="s2">&quot;center_y&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s2">&quot;gamma1&quot;</span><span class="p">:</span> <span class="n">gamma1</span><span class="p">,</span>
            <span class="s2">&quot;gamma2&quot;</span><span class="p">:</span> <span class="n">gamma2</span><span class="p">,</span>
            <span class="s2">&quot;ra_0&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;dec_0&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">]</span>
    
    <span class="n">caustic_double_points</span> <span class="o">=</span> <span class="n">caustics_epl_shear</span><span class="p">(</span>
        <span class="n">kwargs_lens</span><span class="p">,</span> <span class="n">return_which</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">maginf</span><span class="o">=-</span><span class="mi">100</span>
    <span class="p">)</span>
    <span class="n">caustic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">caustic_double_points</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>

    <span class="c1"># If there is a nan, caustic=False, draw a new gamma</span>
    <span class="k">if</span> <span class="n">caustic</span><span class="p">:</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">caustic_double_points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">area</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="p">,</span> <span class="n">area</span></div>


<span class="c1"># def cross_section_interpolated_mp(params):</span>

<span class="c1">#     # theta_E = params[0]</span>
<span class="c1">#     # e1 = np.array(params[1])</span>
<span class="c1">#     # e2 = np.array(params[2])</span>
<span class="c1">#     # gamma = np.array(params[3])</span>
<span class="c1">#     # gamma1 = np.array(params[4])</span>
<span class="c1">#     # gamma2 = np.array(params[5])</span>
<span class="c1">#     # idx = params[6]</span>
<span class="c1">#     # nbrs = params[7]</span>
<span class="c1">#     # values = params[8]</span>
<span class="c1">#     # cross_section_spline = params[9]</span>
<span class="c1">#     # sis_area_array = params[10]</span>
<span class="c1">#     theta_E, e1, e2, gamma, gamma1, gamma2, idx, nbrs, values, cross_section_spline, sis_area_array = params</span>
    
<span class="c1">#     points_ = np.array([e1, e2, gamma, gamma1, gamma2]).T</span>
<span class="c1">#     _, indices = nbrs.kneighbors(points_)</span>
<span class="c1">#     new_values_nn1 = np.mean(values[indices], axis=1)</span>

<span class="c1">#     theta_E_correction = cubic_spline_interpolator(np.pi*theta_E**2, cross_section_spline, sis_area_array)</span>
<span class="c1">#     area = new_values_nn1*theta_E_correction</span>

<span class="c1">#     return idx, area</span>

<div class="viewcode-block" id="cross_section">
<a class="viewcode-back" href="../../../autoapi/ler/lens_galaxy_population/mp/index.html#ler.lens_galaxy_population.cross_section">[docs]</a>
<span class="k">def</span> <span class="nf">cross_section</span><span class="p">(</span><span class="n">theta_E</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">gamma1</span><span class="p">,</span> <span class="n">gamma2</span><span class="p">):</span>

    <span class="n">kwargs_lens</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">&quot;theta_E&quot;</span><span class="p">:</span> <span class="n">theta_E</span><span class="p">,</span>
            <span class="s2">&quot;e1&quot;</span><span class="p">:</span> <span class="n">e1</span><span class="p">,</span>
            <span class="s2">&quot;e2&quot;</span><span class="p">:</span> <span class="n">e2</span><span class="p">,</span>
            <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span>
            <span class="s2">&quot;center_x&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="s2">&quot;center_y&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s2">&quot;gamma1&quot;</span><span class="p">:</span> <span class="n">gamma1</span><span class="p">,</span>
            <span class="s2">&quot;gamma2&quot;</span><span class="p">:</span> <span class="n">gamma2</span><span class="p">,</span>
            <span class="s2">&quot;ra_0&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="s2">&quot;dec_0&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">]</span>
    
    <span class="n">caustic_double_points</span> <span class="o">=</span> <span class="n">caustics_epl_shear</span><span class="p">(</span>
        <span class="n">kwargs_lens</span><span class="p">,</span> <span class="n">return_which</span><span class="o">=</span><span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">maginf</span><span class="o">=-</span><span class="mi">100</span>
    <span class="p">)</span>
    <span class="n">caustic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">caustic_double_points</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span>

    <span class="c1"># If there is a nan, caustic=False, draw a new gamma</span>
    <span class="k">if</span> <span class="n">caustic</span><span class="p">:</span>
        <span class="n">area</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">(</span><span class="n">caustic_double_points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">area</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">area</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">return</span> <span class="n">area</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Phurailatpam Hemantakumar.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>