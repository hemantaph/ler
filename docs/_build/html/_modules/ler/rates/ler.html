

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ler.rates.ler &mdash; ler 0.5.3 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/scalefix.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=776609e1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/dark_mode_css/general.css?v=c0a7eb24" />
      <link rel="stylesheet" type="text/css" href="../../../_static/dark_mode_css/dark.css?v=70edf1c7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=2a2fe768"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="../../../_static/dark_mode_js/default_light.js?v=c2e647ce"></script>
      <script src="../../../_static/dark_mode_js/theme_switcher.js?v=358d3910"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980b9" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ler
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Summary.html">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../code_overview.html">Code overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GW_events.html">Gravitational wave event rates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analytical_formulation_unlensed.html">Analytical Formulation for Gravitational Wave Event Rates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analytical_formulation_unlensed_pdf.html">Analytical Formulation (PDF)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Lensed_events.html">Lensed event rates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Lensed_equations.html">Lensed event sampling (Analytical formulation)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/rates/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.rates</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/gw_source_population/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.gw_source_population</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/lens_galaxy_population/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.lens_galaxy_population</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/image_properties/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.image_properties</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/utils/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.utils</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/LeR_short_examples.html">LeR Short Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/GWRATES_complete_examples.html">GWRATES complete example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/LeR_custom_functions.html">LeR with Custom Functions and Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/LeR_advanced_sampling.html">LeR Advanced Sampling â€” Generating Detectable Events</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #2980b9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ler</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ler.rates.ler</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ler.rates.ler</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for calculating detection rates of gravitational wave events.</span>

<span class="sd">This module contains the main ``LeR`` class for calculating the rates of</span>
<span class="sd">detectable gravitational wave events, both lensed and unlensed. The class</span>
<span class="sd">inherits from :class:`~ler.lens_galaxy_population.LensGalaxyParameterDistribution`</span>
<span class="sd">for source and lens parameters sampling, and utilizes image property calculations.</span>

<span class="sd">The inheritance hierarchy is as follows:</span>

<span class="sd">- :class:`~ler.lens_galaxy_population.LensGalaxyParameterDistribution` \n</span>
<span class="sd">  - :class:`~ler.lens_galaxy_population.OpticalDepth` \n</span>
<span class="sd">  - :class:`~ler.image_properties.ImageProperties` \n</span>
<span class="sd">  - :class:`~ler.gw_source_population.CBCSourceParameterDistribution` \n</span>
<span class="sd">  - :class:`~ler.gw_source_population.CBCSourceRedshiftDistribution` \n</span>
<span class="sd">- Uses the ``gwsnr`` package for pdet calculation.</span>

<span class="sd">Usage:</span>
<span class="sd">    Basic workflow for rate calculation:</span>

<span class="sd">    &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">    &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">    &gt;&gt;&gt; unlensed_params = ler.unlensed_cbc_statistics()</span>
<span class="sd">    &gt;&gt;&gt; ler.unlensed_rate()</span>
<span class="sd">    &gt;&gt;&gt; lensed_params = ler.lensed_cbc_statistics()</span>
<span class="sd">    &gt;&gt;&gt; ler.lensed_rate()</span>
<span class="sd">    &gt;&gt;&gt; ler.rate_ratio()</span>

<span class="sd">Copyright (C) 2026 Phurailatpam Hemantakumar. Distributed under MIT License.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># os.environ[&#39;OMP_NESTED&#39;] = &#39;FALSE&#39;</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">zipfile</span>
<span class="kn">from</span> <span class="nn">importlib_resources</span> <span class="kn">import</span> <span class="n">files</span> <span class="k">as</span> <span class="n">resources_files</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;numexpr.utils&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">astropy.cosmology</span> <span class="kn">import</span> <span class="n">LambdaCDM</span>
<span class="kn">from</span> <span class="nn">..lens_galaxy_population</span> <span class="kn">import</span> <span class="n">LensGalaxyParameterDistribution</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">load_json</span><span class="p">,</span>
    <span class="n">append_json</span><span class="p">,</span>
    <span class="n">get_param_from_json</span><span class="p">,</span>
    <span class="n">batch_handler</span><span class="p">,</span>
    <span class="n">remove_file</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="LeR">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR">[docs]</a>
<span class="k">class</span> <span class="nc">LeR</span><span class="p">(</span><span class="n">LensGalaxyParameterDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class to sample lensed and unlensed GW events and calculate their detection rates.</span>

<span class="sd">    This class provides functionality for sampling gravitational wave source parameters,</span>
<span class="sd">    detection probabilities, and computing detection rates for both lensed and unlensed</span>
<span class="sd">    compact binary coalescence events.</span>
<span class="sd">    Parameters of simulated events are stored in JSON files (not as class attributes)</span>
<span class="sd">    to conserve RAM memory.</span>

<span class="sd">    Key Features: \n</span>
<span class="sd">    - Sampling of unlensed and lensed CBC event parameters \n</span>
<span class="sd">    - Detection probability calculation using ``gwsnr`` package or custom functions \n</span>
<span class="sd">    - Rate calculation for detectable events \n</span>
<span class="sd">    - Batch processing for memory efficiency \n</span>
<span class="sd">    - JSON-based parameter storage for reproducibility \n</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    npool : ``int``</span>
<span class="sd">        Number of cores to use for parallel processing. \n</span>
<span class="sd">        default: 4</span>
<span class="sd">    z_min : ``float``</span>
<span class="sd">        Minimum redshift of the source population. \n</span>
<span class="sd">        default: 0.0</span>
<span class="sd">    z_max : ``float``</span>
<span class="sd">        Maximum redshift of the source population. \n</span>
<span class="sd">        default: 10.0</span>
<span class="sd">    event_type : ``str``</span>
<span class="sd">        Type of event to generate. source_priors and source_priors_params will be set accordingly. \n</span>
<span class="sd">        Options: \n</span>
<span class="sd">        - &#39;BBH&#39;: Binary Black Hole \n</span>
<span class="sd">        - &#39;BNS&#39;: Binary Neutron Star \n</span>
<span class="sd">        - &#39;NSBH&#39;: Neutron Star-Black Hole \n</span>
<span class="sd">        default: &#39;BBH&#39;</span>
<span class="sd">    lens_type : ``str``</span>
<span class="sd">        Type of lens model to use. lens_functions, lens_functions_params, lens_param_samplers and lens_param_samplers_params will be set accordingly. \n</span>
<span class="sd">        Options: \n</span>
<span class="sd">        - &#39;epl_shear_galaxy&#39;: Exponential Power Law Shear Galaxy \n</span>
<span class="sd">        - &#39;sie_galaxy&#39;: Singular Isothermal Ellipsoid Galaxy \n</span>
<span class="sd">        - &#39;sis_galaxy&#39;: Singular Isothermal Sphere Galaxy \n</span>
<span class="sd">        default: &#39;epl_shear_galaxy&#39;</span>
<span class="sd">    cosmology : ``astropy.cosmology``</span>
<span class="sd">        Cosmology to use for the calculation. \n</span>
<span class="sd">        default: LambdaCDM(H0=70, Om0=0.3, Ode0=0.7, Tcmb0=0.0, Neff=3.04, m_nu=None, Ob0=0.0)</span>
<span class="sd">    pdet_finder : ``function`` or ``None``</span>
<span class="sd">        Custom detection probability finder function. \n</span>
<span class="sd">        If None, uses gwsnr&#39;s pdet calculator. \n</span>
<span class="sd">        The function should follow the signature: \n</span>
<span class="sd">        ``def pdet_finder(gw_param_dict): return pdet_net_dict`` \n</span>
<span class="sd">        where pdet_net_dict.keys = [&#39;pdet_net&#39;]. \n</span>
<span class="sd">        default: None</span>
<span class="sd">    json_file_names : ``dict``</span>
<span class="sd">        Names of the JSON files to store the necessary parameters. \n</span>
<span class="sd">        default: dict(</span>
<span class="sd">            ler_params=&quot;ler_params.json&quot;,</span>
<span class="sd">            unlensed_param=&quot;unlensed_param.json&quot;,</span>
<span class="sd">            unlensed_param_detectable=&quot;unlensed_param_detectable.json&quot;,</span>
<span class="sd">            lensed_param=&quot;lensed_param.json&quot;,</span>
<span class="sd">            lensed_param_detectable=&quot;lensed_param_detectable.json&quot;</span>
<span class="sd">        )</span>
<span class="sd">    interpolator_directory : ``str``</span>
<span class="sd">        Directory to store the interpolators. \n</span>
<span class="sd">        default: &#39;./interpolator_json&#39;</span>
<span class="sd">    create_new_interpolator : ``bool`` or ``dict``</span>
<span class="sd">        Whether to create new interpolators. Look at :meth:`~ler.ler_rates.LER.create_new_interpolator` for details. \n</span>
<span class="sd">        Options: \n</span>
<span class="sd">        - True: Create all interpolators anew \n</span>
<span class="sd">        - False: Load existing interpolators if available \n</span>
<span class="sd">        - dict: Specify which interpolators to create new \n</span>
<span class="sd">        default: False</span>
<span class="sd">    ler_directory : ``str``</span>
<span class="sd">        Directory to store the output parameters. \n</span>
<span class="sd">        default: &#39;./ler_data&#39;</span>
<span class="sd">    verbose : ``bool``</span>
<span class="sd">        If True, print all chosen parameters during initialization. \n</span>
<span class="sd">        default: True</span>
<span class="sd">    **kwargs : ``dict``</span>
<span class="sd">        Additional keyword arguments passed to parent classes: \n</span>
<span class="sd">        :class:`~ler.lens_galaxy_population.LensGalaxyParameterDistribution`, \n</span>
<span class="sd">        :class:`~ler.gw_source_population.CBCSourceParameterDistribution`, \n</span>
<span class="sd">        :class:`~ler.image_properties.ImageProperties`, and \n</span>
<span class="sd">        :class:`~gwsnr.GWSNR` (if snr_finder=&#39;gwsnr&#39;).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Basic usage:</span>

<span class="sd">    &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">    &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">    &gt;&gt;&gt; unlensed_params = ler.unlensed_cbc_statistics()</span>
<span class="sd">    &gt;&gt;&gt; ler.unlensed_rate()</span>
<span class="sd">    &gt;&gt;&gt; lensed_params = ler.lensed_cbc_statistics()</span>
<span class="sd">    &gt;&gt;&gt; ler.lensed_rate()</span>
<span class="sd">    &gt;&gt;&gt; ler.rate_ratio()</span>


<span class="sd">    Instance Methods</span>
<span class="sd">    ----------</span>
<span class="sd">    LeR class has the following methods: \n</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | Method                                              | Description                                    |</span>
<span class="sd">    +=====================================================+================================================+</span>
<span class="sd">    | :meth:`~unlensed_cbc_statistics`                    | Generate unlensed GW source parameters         |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~unlensed_sampling_routine`                  | Generate unlensed parameters with batching     |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~unlensed_rate`                              | Calculate the unlensed detection rate          |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~lensed_cbc_statistics`                      | Generate lensed GW source parameters           |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~lensed_sampling_routine`                    | Generate lensed parameters with batching       |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~lensed_rate`                                | Calculate the lensed detection rate            |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~rate_function`                              | General helper for rate calculation            |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~rate_ratio`                                 | Calculate lensed/unlensed rate ratio           |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~rate_comparison_with_rate_calculation`      | Calculate and compare lensed/unlensed rates    |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~selecting_n_unlensed_detectable_events`     | Select n unlensed detectable events            |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~selecting_n_lensed_detectable_events`       | Select n lensed detectable events              |</span>
<span class="sd">    +-----------------------------------------------------+------------------------------------------------+</span>


<span class="sd">    Instance Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    LeR class has the following attributes: \n</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | Attribute                                      | Type             | Unit  | Description                                    |</span>
<span class="sd">    +================================================+==================+=======+================================================+</span>
<span class="sd">    | :meth:`~npool`                                 | ``int``          |       | Number of parallel processing cores            |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~z_min`                                 | ``float``        |       | Minimum source redshift                        |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~z_max`                                 | ``float``        |       | Maximum source redshift                        |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~event_type`                            | ``str``          |       | Type of CBC event (BBH, BNS, NSBH)             |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~lens_type`                             | ``str``          |       | Type of lens galaxy model                      |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~cosmo`                                 | ``Cosmology``    |       | Astropy cosmology object                       |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~json_file_names`                       | ``dict``         |       | JSON file names for parameter storage          |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~interpolator_directory`                | ``str``          |       | Directory for interpolator files               |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~ler_directory`                         | ``str``          |       | Directory for output parameter files           |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~pdet_finder`                           | ``callable``     |       | Detection probability finder function          |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~ler_args`                              | ``dict``         |       | All LeR initialization arguments               |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>
<span class="sd">    | :meth:`~create_new_interpolator`               | ``dict``         |       | Interpolator creation settings                 |</span>
<span class="sd">    +------------------------------------------------+------------------+-------+------------------------------------------------+</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - ``LeR`` class inherits from :class:`~ler.lens_galaxy_population.LensGalaxyParameterDistribution`. \n</span>
<span class="sd">      Refer to that class for additional inherited attributes and methods. \n</span>
<span class="sd">    - Parameters are stored in JSON files for memory efficiency and reproducibility. \n</span>
<span class="sd">    - For stable rate estimates, use size &gt;= 1e6 samples. \n</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">npool</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
        <span class="n">z_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">z_max</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
        <span class="n">event_type</span><span class="o">=</span><span class="s2">&quot;BBH&quot;</span><span class="p">,</span>
        <span class="n">lens_type</span><span class="o">=</span><span class="s2">&quot;epl_shear_galaxy&quot;</span><span class="p">,</span>
        <span class="n">cosmology</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pdet_finder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># if not given, gwsnr&#39;s pdet calculator will be used</span>
        <span class="n">json_file_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">interpolator_directory</span><span class="o">=</span><span class="s2">&quot;./interpolator_json&quot;</span><span class="p">,</span>
        <span class="n">create_new_interpolator</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ler_directory</span><span class="o">=</span><span class="s2">&quot;./ler_data&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="c1"># getting interpolator data from the package</span>
        <span class="c1"># first check if the interpolator directory &#39;./interpolator_json&#39; exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">interpolator_directory</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="c1"># Get the path to the zip resource using importlib_resources</span>
            <span class="n">zip_resource</span> <span class="o">=</span> <span class="n">resources_files</span><span class="p">(</span><span class="s1">&#39;ler.rates&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">joinpath</span><span class="p">(</span><span class="s1">&#39;ler_data&#39;</span><span class="p">,</span> <span class="s1">&#39;interpolator_json.zip&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">zip_resource</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">zip_file</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Extracting interpolator data from package to the current working directory.&quot;</span><span class="p">)</span>

                <span class="c1"># Define destination path (current working directory)</span>
                <span class="n">dest_path</span> <span class="o">=</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">cwd</span><span class="p">()</span>

                <span class="c1"># Extract the zip file, skipping __MACOSX metadata</span>
                <span class="k">with</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="n">zip_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">zip_ref</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">member</span> <span class="ow">in</span> <span class="n">zip_ref</span><span class="o">.</span><span class="n">namelist</span><span class="p">():</span>
                        <span class="c1"># Skip __MACOSX directory and its contents</span>
                        <span class="k">if</span> <span class="n">member</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__MACOSX&#39;</span><span class="p">):</span>
                            <span class="k">continue</span>
                        <span class="n">zip_ref</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="n">member</span><span class="p">,</span> <span class="n">dest_path</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Initializing LeR class...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># init ler attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npool</span> <span class="o">=</span> <span class="n">npool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span> <span class="o">=</span> <span class="n">z_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="o">=</span> <span class="n">z_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">event_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lens_type</span> <span class="o">=</span> <span class="n">lens_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cosmo</span> <span class="o">=</span> <span class="n">cosmology</span> <span class="k">if</span> <span class="n">cosmology</span> <span class="k">else</span> <span class="n">LambdaCDM</span><span class="p">(</span><span class="n">H0</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">Om0</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">Ode0</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">Tcmb0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">Neff</span><span class="o">=</span><span class="mf">3.04</span><span class="p">,</span> <span class="n">m_nu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Ob0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>

        <span class="c1"># init json file names where datas will be stored</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">ler_params</span><span class="o">=</span><span class="s2">&quot;ler_params.json&quot;</span><span class="p">,</span>
            <span class="n">unlensed_param</span><span class="o">=</span><span class="s2">&quot;unlensed_param.json&quot;</span><span class="p">,</span>
            <span class="n">unlensed_param_detectable</span><span class="o">=</span><span class="s2">&quot;unlensed_param_detectable.json&quot;</span><span class="p">,</span>
            <span class="n">lensed_param</span><span class="o">=</span><span class="s2">&quot;lensed_param.json&quot;</span><span class="p">,</span>
            <span class="n">lensed_param_detectable</span><span class="o">=</span><span class="s2">&quot;lensed_param_detectable.json&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">json_file_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">json_file_names</span><span class="p">)</span>

        <span class="c1"># init interpolator directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator_directory</span> <span class="o">=</span> <span class="n">interpolator_directory</span>
        <span class="c1"># kwargs will be passed as input for the parent class</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_interpolator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">=</span> <span class="n">ler_directory</span>
        <span class="c1"># create directory if not exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ler_directory</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">ler_directory</span><span class="p">)</span>

        <span class="c1"># parent class initialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_class_initialization</span><span class="p">(</span>
            <span class="n">params</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">pdet_finder</span><span class="o">=</span><span class="n">pdet_finder</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parent_class_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pdet_finder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to initialize the parent classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ``dict``</span>
<span class="sd">            dictionary of parameters to initialize the parent classes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">initialization</span><span class="p">():</span>
            <span class="c1"># initialization of parent class</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent_initialization_helper</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
            <span class="c1"># initialization self.snr and self.pdet_finder from GWSNR class</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pdet_finder</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdet_finder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gwsnr_initialization</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdet_finder</span> <span class="o">=</span> <span class="n">pdet_finder</span>

            <span class="c1"># store all the ler input parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_store_ler_params</span><span class="p">(</span><span class="n">output_jsonfile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>

        <span class="c1"># if not verbose, prevent anything from printing</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">initialization</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_print_all_init_args</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">initialization</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_parent_initialization_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to initialize the parent classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ``dict``</span>
<span class="sd">            dictionary of parameters to initialize the parent classes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialization of LensGalaxyParameterDistribution class</span>
        <span class="c1"># it also initializes the CBCSourceParameterDistribution and ImageProperties classes</span>
        <span class="n">input_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="c1"># LensGalaxyParameterDistribution class params</span>
            <span class="c1">#    OpticalDepth class params</span>
            <span class="n">npool</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npool</span><span class="p">,</span>
            <span class="n">z_min</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">,</span>
            <span class="n">z_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">,</span>
            <span class="n">cosmology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cosmo</span><span class="p">,</span>
            <span class="n">lens_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_type</span><span class="p">,</span>
            <span class="n">lens_functions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">lens_functions_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">lens_param_samplers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">lens_param_samplers_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">directory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolator_directory</span><span class="p">,</span>
            <span class="n">create_new_interpolator</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="c1"># ImageProperties class params</span>
            <span class="n">n_min_images</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">n_max_images</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="n">time_window</span><span class="o">=</span><span class="mi">365</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">3600</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">lens_model_list</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;EPL_NUMBA&quot;</span><span class="p">,</span> <span class="s2">&quot;SHEAR&quot;</span><span class="p">],</span>
            <span class="n">effective_params_in_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="c1"># CBCSourceParameterDistribution class params</span>
            <span class="n">event_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">event_type</span><span class="p">,</span>
            <span class="n">source_priors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">source_priors_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">spin_zero</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">spin_precession</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># update input_params with params. This will include create_new_interpolator.</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">input_params</span><span class="p">:</span>
                    <span class="n">input_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># initialization of parent class</span>
        <span class="n">LensGalaxyParameterDistribution</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="c1"># LensGalaxyParameterDistribution class params</span>
            <span class="c1">#    OpticalDepth class params</span>
            <span class="n">npool</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;npool&quot;</span><span class="p">],</span>
            <span class="n">z_min</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;z_min&quot;</span><span class="p">],</span>
            <span class="n">z_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;z_max&quot;</span><span class="p">],</span>
            <span class="n">cosmology</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;cosmology&quot;</span><span class="p">],</span>
            <span class="n">lens_type</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_type&quot;</span><span class="p">],</span>
            <span class="n">lens_functions</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_functions&quot;</span><span class="p">],</span>
            <span class="n">lens_functions_params</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_functions_params&quot;</span><span class="p">],</span>
            <span class="n">lens_param_samplers</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers&quot;</span><span class="p">],</span>
            <span class="n">lens_param_samplers_params</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers_params&quot;</span><span class="p">],</span>
            <span class="n">directory</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;directory&quot;</span><span class="p">],</span>
            <span class="n">create_new_interpolator</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">],</span>
            <span class="c1"># ImageProperties class params</span>
            <span class="n">n_min_images</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;n_min_images&quot;</span><span class="p">],</span>
            <span class="n">n_max_images</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;n_max_images&quot;</span><span class="p">],</span>
            <span class="n">time_window</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;time_window&quot;</span><span class="p">],</span>
            <span class="n">effective_params_in_output</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;effective_params_in_output&quot;</span><span class="p">],</span>
            <span class="n">lens_model_list</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_model_list&quot;</span><span class="p">],</span>
            <span class="c1"># CBCSourceParameterDistribution class params</span>
            <span class="n">event_type</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;event_type&quot;</span><span class="p">],</span>
            <span class="n">source_priors</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;source_priors&quot;</span><span class="p">],</span>
            <span class="n">source_priors_params</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;source_priors_params&quot;</span><span class="p">],</span>
            <span class="n">spin_zero</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;spin_zero&quot;</span><span class="p">],</span>
            <span class="n">spin_precession</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;spin_precession&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># some of the None values will have default values after initialization</span>
        <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;source_priors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;source_priors_params&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers_params&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_functions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_functions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_functions_params&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_functions_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_new_interpolator</span>

        <span class="c1"># save input_params to self.ler_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span> <span class="o">=</span> <span class="n">input_params</span>

    <span class="k">def</span> <span class="nf">_gwsnr_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to initialize the GWSNR class from the `gwsnr` package.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : ``dict``</span>
<span class="sd">            dictionary of parameters to initialize the gwsnr class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">gwsnr</span> <span class="kn">import</span> <span class="n">GWSNR</span>

        <span class="c1"># initialization of GWSNR class</span>
        <span class="k">if</span> <span class="s2">&quot;mminbh&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;source_frame_masses&quot;</span><span class="p">]:</span>
            <span class="n">min_bh_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;source_frame_masses&quot;</span><span class="p">][</span><span class="s2">&quot;mminbh&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_bh_mass</span> <span class="o">=</span> <span class="mf">2.0</span>

        <span class="k">if</span> <span class="s2">&quot;mmaxbh&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;source_frame_masses&quot;</span><span class="p">]:</span>
            <span class="n">max_bh_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;source_frame_masses&quot;</span><span class="p">][</span><span class="s2">&quot;mmaxbh&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_bh_mass</span> <span class="o">=</span> <span class="mf">200.0</span>
        <span class="n">input_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="c1"># General settings</span>
            <span class="n">npool</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npool</span><span class="p">,</span>
            <span class="n">snr_method</span><span class="o">=</span><span class="s2">&quot;interpolation_aligned_spins&quot;</span><span class="p">,</span>
            <span class="n">snr_type</span><span class="o">=</span><span class="s2">&quot;optimal_snr&quot;</span><span class="p">,</span>
            <span class="n">gwsnr_verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">multiprocessing_verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">pdet_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="c1"># Settings for interpolation grid</span>
            <span class="n">mtot_min</span><span class="o">=</span><span class="n">min_bh_mass</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">mtot_max</span><span class="o">=</span><span class="p">(</span>
                <span class="n">max_bh_mass</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">max_bh_mass</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">500.0</span>
                <span class="k">else</span> <span class="mf">500.0</span>
            <span class="p">),</span>
            <span class="n">ratio_min</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">ratio_max</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">spin_max</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span>
            <span class="n">mtot_resolution</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
            <span class="n">ratio_resolution</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
            <span class="n">spin_resolution</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">batch_size_interpolation</span><span class="o">=</span><span class="mi">1000000</span><span class="p">,</span>
            <span class="n">interpolator_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">directory</span><span class="p">,</span>
            <span class="n">create_new_interpolator</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="c1"># GW signal settings</span>
            <span class="n">sampling_frequency</span><span class="o">=</span><span class="mf">2048.0</span><span class="p">,</span>
            <span class="n">waveform_approximant</span><span class="o">=</span><span class="s2">&quot;IMRPhenomD&quot;</span><span class="p">,</span>
            <span class="n">frequency_domain_source_model</span><span class="o">=</span><span class="s2">&quot;lal_binary_black_hole&quot;</span><span class="p">,</span>
            <span class="n">minimum_frequency</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span>
            <span class="n">reference_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">duration_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">duration_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fixed_duration</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">mtot_cut</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="c1"># Detector settings</span>
            <span class="n">psds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ifos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">noise_realization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># not implemented yet</span>
            <span class="c1"># ANN settings</span>
            <span class="n">ann_path_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="c1"># Hybrid SNR recalculation settings</span>
            <span class="n">snr_recalculation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">snr_recalculation_range</span><span class="o">=</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">14</span><span class="p">],</span>
            <span class="n">snr_recalculation_waveform_approximant</span><span class="o">=</span><span class="s2">&quot;IMRPhenomXPHM&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># update input_params with params. This will include create_new_interpolator.</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">input_params</span><span class="p">:</span>
                    <span class="n">input_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;pdet_args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_params</span>

        <span class="c1"># dealing with create_new_interpolator param</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># check input_params[&quot;gwsnr&quot;] exists</span>
            <span class="k">if</span> <span class="s2">&quot;gwsnr&quot;</span> <span class="ow">in</span> <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">][</span><span class="s2">&quot;gwsnr&quot;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">):</span>
                    <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_params</span><span class="p">[</span>
                        <span class="s2">&quot;create_new_interpolator&quot;</span>
                    <span class="p">][</span><span class="s2">&quot;gwsnr&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;create_new_interpolator[&#39;gwsnr&#39;] should be a boolean.&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># initialization of GWSNR class</span>
        <span class="n">gwsnr</span> <span class="o">=</span> <span class="n">GWSNR</span><span class="p">(</span>
            <span class="c1"># General settings</span>
            <span class="n">npool</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;npool&quot;</span><span class="p">],</span>
            <span class="n">snr_method</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;snr_method&quot;</span><span class="p">],</span>
            <span class="n">snr_type</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;snr_type&quot;</span><span class="p">],</span>
            <span class="n">gwsnr_verbose</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;gwsnr_verbose&quot;</span><span class="p">],</span>
            <span class="n">multiprocessing_verbose</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;multiprocessing_verbose&quot;</span><span class="p">],</span>
            <span class="n">pdet_kwargs</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;pdet_kwargs&quot;</span><span class="p">],</span>
            <span class="c1"># Settings for interpolation grid</span>
            <span class="n">mtot_min</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;mtot_min&quot;</span><span class="p">],</span>
            <span class="n">mtot_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;mtot_max&quot;</span><span class="p">],</span>
            <span class="n">ratio_min</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ratio_min&quot;</span><span class="p">],</span>
            <span class="n">ratio_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ratio_max&quot;</span><span class="p">],</span>
            <span class="n">spin_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;spin_max&quot;</span><span class="p">],</span>
            <span class="n">mtot_resolution</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;mtot_resolution&quot;</span><span class="p">],</span>
            <span class="n">ratio_resolution</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ratio_resolution&quot;</span><span class="p">],</span>
            <span class="n">spin_resolution</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;spin_resolution&quot;</span><span class="p">],</span>
            <span class="n">batch_size_interpolation</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;batch_size_interpolation&quot;</span><span class="p">],</span>
            <span class="n">interpolator_dir</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;interpolator_dir&quot;</span><span class="p">],</span>
            <span class="n">create_new_interpolator</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">],</span>
            <span class="c1"># GW signal settings</span>
            <span class="n">sampling_frequency</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;sampling_frequency&quot;</span><span class="p">],</span>
            <span class="n">waveform_approximant</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;waveform_approximant&quot;</span><span class="p">],</span>
            <span class="n">frequency_domain_source_model</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;frequency_domain_source_model&quot;</span><span class="p">],</span>
            <span class="n">minimum_frequency</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;minimum_frequency&quot;</span><span class="p">],</span>
            <span class="n">reference_frequency</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;reference_frequency&quot;</span><span class="p">],</span>
            <span class="n">duration_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;duration_max&quot;</span><span class="p">],</span>
            <span class="n">duration_min</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;duration_min&quot;</span><span class="p">],</span>
            <span class="n">fixed_duration</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;fixed_duration&quot;</span><span class="p">],</span>
            <span class="n">mtot_cut</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;mtot_cut&quot;</span><span class="p">],</span>
            <span class="c1"># Detector settings</span>
            <span class="n">psds</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;psds&quot;</span><span class="p">],</span>
            <span class="n">ifos</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ifos&quot;</span><span class="p">],</span>
            <span class="n">noise_realization</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;noise_realization&quot;</span><span class="p">],</span>
            <span class="c1"># ANN settings</span>
            <span class="n">ann_path_dict</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ann_path_dict&quot;</span><span class="p">],</span>
            <span class="c1"># Hybrid SNR recalculation settings</span>
            <span class="n">snr_recalculation</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;snr_recalculation&quot;</span><span class="p">],</span>
            <span class="n">snr_recalculation_range</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;snr_recalculation_range&quot;</span><span class="p">],</span>
            <span class="n">snr_recalculation_waveform_approximant</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span>
                <span class="s2">&quot;snr_recalculation_waveform_approximant&quot;</span>
            <span class="p">],</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;pdet_args&quot;</span><span class="p">][</span><span class="s2">&quot;pdet_kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gwsnr</span><span class="o">.</span><span class="n">pdet_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;pdet_args&quot;</span><span class="p">][</span><span class="s2">&quot;psds_list&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gwsnr</span><span class="o">.</span><span class="n">psds_list</span>

        <span class="k">return</span> <span class="n">gwsnr</span><span class="o">.</span><span class="n">pdet</span>

    <span class="k">def</span> <span class="nf">_print_all_init_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to print all the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># print all relevant functions and sampler priors</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;#-------------------------------------&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# LeR initialization input arguments:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;#-------------------------------------</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    # LeR set up input arguments:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    npool = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">npool</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    z_min = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    z_max = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    event_type = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">event_type</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    lens_type = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_type</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    cosmology = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cosmo</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    pdet_finder = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pdet_finder</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    json_file_names = dict(&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="p">(</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ),&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    interpolator_directory = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolator_directory</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    ler_directory = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    create_new_interpolator = dict(&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="p">(</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ),&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    # LeR also takes other CBCSourceParameterDistribution class input arguments as kwargs, as follows:&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    source_priors = dict(&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;source_priors&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="p">(</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ),&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    source_priors_params = dict(&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;source_priors_params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="p">(</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ),&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    spin_zero = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s1">&#39;spin_zero&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    spin_precession = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s1">&#39;spin_precession&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    # LeR also takes other LensGalaxyParameterDistribution class input arguments as kwargs, as follows:&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    lens_functions = dict(&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;lens_functions&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="p">(</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ),&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    lens_functions_params = dict(&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;lens_functions_params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="p">(</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ),&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    lens_param_samplers = dict(&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="p">(</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ),&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    lens_param_samplers_params = dict(&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers_params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="p">(</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ),&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    # LeR also takes other ImageProperties class input arguments as kwargs, as follows:&quot;</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    n_min_images = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s1">&#39;n_min_images&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    n_max_images = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s1">&#39;n_max_images&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    time_window = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s1">&#39;time_window&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    effective_params_in_output = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s1">&#39;effective_params_in_output&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    lens_model_list = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s1">&#39;lens_model_list&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;pdet_args&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    # LeR also takes other gwsnr.GWSNR input arguments as kwargs, as follows:&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="p">[</span><span class="s2">&quot;pdet_args&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = dict(&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="p">(</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                            <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;        </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    ),&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="p">(</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = &#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
                        <span class="k">else</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
                    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_store_ler_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to store the all the necessary parameters. This is useful for reproducing the results. All the parameters stored are in string format to make it json compatible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            name of the json file to store the parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># ler params</span>
        <span class="n">param_sampler_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_args</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># convert all dict values to str</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param_sampler_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">param_sampler_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">file_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">]</span>
        <span class="n">append_json</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">param_sampler_dict</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

<div class="viewcode-block" id="LeR.unlensed_cbc_statistics">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.unlensed_cbc_statistics">[docs]</a>
    <span class="k">def</span> <span class="nf">unlensed_cbc_statistics</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span>
        <span class="n">resume</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">save_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate unlensed GW source parameters.</span>

<span class="sd">        This function calls the unlensed_sampling_routine function to generate</span>
<span class="sd">        the parameters in batches. The generated parameters are stored in a JSON</span>
<span class="sd">        file; and if save_batch=True, it keeps updating the file in batches.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : ``int``</span>
<span class="sd">            Number of samples to generate. \n</span>
<span class="sd">            default: 100000</span>
<span class="sd">        batch_size : ``int``</span>
<span class="sd">            Batch size for sampling. \n</span>
<span class="sd">            default: 50000</span>
<span class="sd">        resume : ``bool``</span>
<span class="sd">            If True, the function will resume from the last batch. \n</span>
<span class="sd">            default: True</span>
<span class="sd">        save_batch : ``bool``</span>
<span class="sd">            If True, saves parameters in batches during sampling. \n</span>
<span class="sd">            If False, saves all parameters at the end (faster). \n</span>
<span class="sd">            default: False</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            JSON file name for storing the parameters. \n</span>
<span class="sd">            default: None (uses self.json_file_names[&quot;unlensed_param&quot;])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unlensed_param : ``dict``</span>
<span class="sd">            Dictionary of unlensed GW source parameters. The included parameters and their units are as follows (for default settings):\n</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | Parameter          | Units        | Description                          |</span>
<span class="sd">            +====================+==============+======================================+</span>
<span class="sd">            | zs                 |              | redshift of the source               |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | geocent_time       | s            | GPS time of coalescence              |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | ra                 | rad          | right ascension                      |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | dec                | rad          | declination                          |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | phase              | rad          | phase of GW at reference frequency   |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | psi                | rad          | polarization angle                   |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | theta_jn           | rad          | inclination angle                    |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | a_1                |              | spin_1 of the compact binary         |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | a_2                |              | spin_2 of the compact binary         |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | luminosity_distance| Mpc          | luminosity distance                  |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | mass_1_source      | Msun         | mass_1 of the compact binary         |</span>
<span class="sd">            |                    |              | (source frame)                       |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | mass_2_source      | Msun         | mass_2 of the compact binary         |</span>
<span class="sd">            |                    |              | (source frame)                       |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | mass_1             | Msun         | mass_1 of the compact binary         |</span>
<span class="sd">            |                    |              | (detector frame)                     |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | mass_2             | Msun         | mass_2 of the compact binary         |</span>
<span class="sd">            |                    |              | (detector frame)                     |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | pdet_L1            |              | pdet of L1                           |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | pdet_H1            |              | pdet of H1                           |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | pdet_V1            |              | pdet of V1                           |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>
<span class="sd">            | pdet_net           |              | pdet of the network                  |</span>
<span class="sd">            +--------------------+--------------+--------------------------------------+</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; unlensed_param = ler.unlensed_cbc_statistics()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Note: size must be provided as argument, no default fallback</span>
        <span class="n">output_jsonfile</span> <span class="o">=</span> <span class="n">output_jsonfile</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;unlensed_param&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;unlensed_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_jsonfile</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unlensed params will be stored in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">unlensed_param</span> <span class="o">=</span> <span class="n">batch_handler</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">sampling_routine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unlensed_sampling_routine</span><span class="p">,</span>
            <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">output_path</span><span class="p">,</span>
            <span class="n">save_batch</span><span class="o">=</span><span class="n">save_batch</span><span class="p">,</span>
            <span class="n">resume</span><span class="o">=</span><span class="n">resume</span><span class="p">,</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;unlensed parameters&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">unlensed_param</span></div>


<div class="viewcode-block" id="LeR.unlensed_sampling_routine">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.unlensed_sampling_routine">[docs]</a>
    <span class="k">def</span> <span class="nf">unlensed_sampling_routine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_batch</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate unlensed GW source parameters for a single batch.</span>

<span class="sd">        This is the core sampling routine called by unlensed_cbc_statistics.</span>
<span class="sd">        It samples GW source parameters and calculates detection probabilities.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : ``int``</span>
<span class="sd">            Number of samples to generate.</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            JSON file name for storing the parameters.</span>
<span class="sd">        resume : ``bool``</span>
<span class="sd">            If True, appends new samples to existing JSON file. \n</span>
<span class="sd">            default: True</span>
<span class="sd">        save_batch : ``bool``</span>
<span class="sd">            If True, saves parameters in batches during sampling. \n</span>
<span class="sd">            default: True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        unlensed_param : ``dict``</span>
<span class="sd">            Dictionary of unlensed GW source parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get gw params</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sampling gw source params...&quot;</span><span class="p">)</span>
        <span class="n">unlensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_gw_parameters</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># Get pdet</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating pdet...&quot;</span><span class="p">)</span>
        <span class="n">pdet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdet_finder</span><span class="p">(</span><span class="n">gw_param_dict</span><span class="o">=</span><span class="n">unlensed_param</span><span class="p">)</span>
        <span class="n">unlensed_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pdet</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unlensed_param</span></div>


<div class="viewcode-block" id="LeR.unlensed_rate">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.unlensed_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">unlensed_rate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">unlensed_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pdet_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">pdet_type</span><span class="o">=</span><span class="s2">&quot;boolean&quot;</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate the unlensed rate.</span>

<span class="sd">        This function calculates the detection rate for unlensed events and stores</span>
<span class="sd">        the parameters of the detectable events in a JSON file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param : ``dict`` or ``str``</span>
<span class="sd">            Dictionary of GW source parameters or JSON file name. \n</span>
<span class="sd">            default: None (uses self.json_file_names[&quot;unlensed_param&quot;])</span>
<span class="sd">        pdet_threshold : ``float``</span>
<span class="sd">            Threshold for detection probability. \n</span>
<span class="sd">            default: 0.5</span>
<span class="sd">        pdet_type : ``str``</span>
<span class="sd">            Detectability condition type. \n</span>
<span class="sd">            Options: \n</span>
<span class="sd">            - &#39;boolean&#39;: Binary detection based on pdet_threshold \n</span>
<span class="sd">            - &#39;probability_distribution&#39;: Uses pdet values directly \n</span>
<span class="sd">            default: &#39;boolean&#39;</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            JSON file name for storing the parameters of the detectable events. \n</span>
<span class="sd">            default: None (uses self.json_file_names[&quot;unlensed_param_detectable&quot;])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_rate : ``float``</span>
<span class="sd">            Total unlensed rate (yr^-1).</span>
<span class="sd">        unlensed_param : ``dict``</span>
<span class="sd">            Dictionary of unlensed GW source parameters of the detectable events.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; ler.unlensed_cbc_statistics()</span>
<span class="sd">        &gt;&gt;&gt; total_rate, unlensed_param_detectable = ler.unlensed_rate()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">unlensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_param</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">)</span>
        <span class="n">total_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>

        <span class="c1"># find index of detectable events</span>
        <span class="n">pdet</span> <span class="o">=</span> <span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span>
        <span class="n">idx_detectable</span> <span class="o">=</span> <span class="n">pdet</span> <span class="o">&gt;</span> <span class="n">pdet_threshold</span>

        <span class="k">if</span> <span class="n">pdet_type</span> <span class="o">==</span> <span class="s2">&quot;boolean&quot;</span><span class="p">:</span>
            <span class="n">detectable_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx_detectable</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pdet_type</span> <span class="o">==</span> <span class="s2">&quot;probability_distribution&quot;</span><span class="p">:</span>
            <span class="n">detectable_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pdet</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;pdet_type not recognized&quot;</span><span class="p">)</span>
        <span class="c1"># montecarlo integration``</span>
        <span class="c1"># The total rate R = norm &lt;Theta(rho-rhoc)&gt;</span>
        <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span>
            <span class="n">detectable_events</span><span class="p">,</span> <span class="n">total_events</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span>
        <span class="p">)</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_detectable_params</span><span class="p">(</span>
            <span class="n">output_jsonfile</span><span class="p">,</span>
            <span class="n">unlensed_param</span><span class="p">,</span>
            <span class="n">idx_detectable</span><span class="p">,</span>
            <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;unlensed_param_detectable&quot;</span><span class="p">,</span>
            <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># append ler_param and save it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_ler_param</span><span class="p">(</span><span class="n">total_rate</span><span class="p">,</span> <span class="n">pdet_type</span><span class="o">=</span><span class="n">pdet_type</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">total_rate</span><span class="p">,</span> <span class="n">unlensed_param</span></div>


    <span class="k">def</span> <span class="nf">_load_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to load or copy unlensed/lensed parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param : ``dict`` or ``str``</span>
<span class="sd">            dictionary of unlensed/lensed parameters or json file name.</span>
<span class="sd">        param_type : ``str``</span>
<span class="sd">            type of parameters.</span>
<span class="sd">            default param_type = &#39;unlensed&#39;. Other options is &#39;lensed&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        param : ``dict``</span>
<span class="sd">            dictionary of unlensed/lensed parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">param_type</span> <span class="o">=</span> <span class="n">param_type</span> <span class="o">+</span> <span class="s2">&quot;_param&quot;</span>
        <span class="k">if</span> <span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="n">param_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">path_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">param</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> from json file </span><span class="si">{</span><span class="n">path_</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">path_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Using provided </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> dict...&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">param</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="LeR.rate_function">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.rate_function">[docs]</a>
    <span class="k">def</span> <span class="nf">rate_function</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">detectable_size</span><span class="p">,</span> <span class="n">total_size</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the detection rate for unlensed or lensed events.</span>

<span class="sd">        This is a general helper function that computes the rate based on</span>
<span class="sd">        Monte Carlo integration using the ratio of detectable to total events.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        detectable_size : ``int`` or ``float``</span>
<span class="sd">            Number of detectable events (or sum of pdet values).</span>
<span class="sd">        total_size : ``int``</span>
<span class="sd">            Total number of simulated events.</span>
<span class="sd">        param_type : ``str``</span>
<span class="sd">            Type of parameters. \n</span>
<span class="sd">            Options: \n</span>
<span class="sd">            - &#39;unlensed&#39;: Use unlensed normalization \n</span>
<span class="sd">            - &#39;lensed&#39;: Use lensed normalization \n</span>
<span class="sd">            default: &#39;unlensed&#39;</span>
<span class="sd">        verbose : ``bool``</span>
<span class="sd">            If True, print rate information. \n</span>
<span class="sd">            default: True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rate : ``float``</span>
<span class="sd">            Event rate (yr^-1).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; rate = ler.rate_function(detectable_size=100, total_size=1000)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">param_type</span> <span class="o">==</span> <span class="s2">&quot;unlensed&quot;</span><span class="p">:</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_pdf_z</span>
        <span class="k">elif</span> <span class="n">param_type</span> <span class="o">==</span> <span class="s2">&quot;lensed&quot;</span><span class="p">:</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_pdf_z_lensed</span>
        <span class="n">rate</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">normalization</span> <span class="o">*</span> <span class="n">detectable_size</span> <span class="o">/</span> <span class="n">total_size</span><span class="p">)</span>
        <span class="c1"># print(f&quot;\nnormalization factor for {param_type} rate: {normalization}&quot;)</span>
        <span class="c1"># print(f&quot;detectable size: {detectable_size}&quot;)</span>
        <span class="c1"># print(f&quot;total size: {total_size}&quot;)</span>
        <span class="c1"># print(f&quot;calculated {param_type} rate: {rate}\n&quot;)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> rate (yr^-1): </span><span class="si">{</span><span class="n">rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;number of simulated </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> detectable events: </span><span class="si">{</span><span class="n">detectable_size</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;number of simulated all </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> events: </span><span class="si">{</span><span class="n">total_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rate</span></div>


    <span class="k">def</span> <span class="nf">_save_detectable_params</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="p">,</span>
        <span class="n">param</span><span class="p">,</span>
        <span class="n">idx_detectable</span><span class="p">,</span>
        <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;unlensed_param_detectable&quot;</span><span class="p">,</span>
        <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to save the detectable parameters in json file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            json file name for storing the parameters of the detectable events. This is stored in the self.ler_directory.</span>
<span class="sd">        param : ``dict``</span>
<span class="sd">            dictionary of GW source parameters.</span>
<span class="sd">        idx_detectable : ``numpy.ndarray``</span>
<span class="sd">            index of detectable events.</span>
<span class="sd">        key_file_name : ``str``</span>
<span class="sd">            key name for the json file to be added in self.json_file_names.</span>
<span class="sd">        nan_to_num : ``bool``</span>
<span class="sd">            if True, it will replace nan with 0.</span>
<span class="sd">            default nan_to_num = False.</span>
<span class="sd">        verbose : ``bool``</span>
<span class="sd">            if True, it will print the path of the json file.</span>
<span class="sd">            default verbose = True.</span>
<span class="sd">        replace_jsonfile : ``bool``</span>
<span class="sd">            if True, it will replace the json file. If False, it will append the json file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="k">if</span> <span class="n">nan_to_num</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">idx_detectable</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">idx_detectable</span><span class="p">]</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="k">if</span> <span class="n">output_jsonfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_jsonfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="n">key_file_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="n">key_file_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_jsonfile</span>

        <span class="n">output_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">output_jsonfile</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;storing detectable params in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace_jsonfile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_append_ler_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total_rate</span><span class="p">,</span> <span class="n">pdet_type</span><span class="o">=</span><span class="s2">&quot;boolean&quot;</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to append the final results, total_rate, in the json file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        total_rate : ``float``</span>
<span class="sd">            total rate.</span>
<span class="sd">        param_type : ``str``</span>
<span class="sd">            type of parameters.</span>
<span class="sd">            default param_type = &#39;unlensed&#39;. Other options is &#39;lensed&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>
        <span class="c1"># write the results</span>
        <span class="n">data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;detectable_</span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2">_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>
        <span class="n">data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;pdet_type_</span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdet_type</span>
        <span class="n">append_json</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">],</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="LeR.lensed_cbc_statistics">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.lensed_cbc_statistics">[docs]</a>
    <span class="k">def</span> <span class="nf">lensed_cbc_statistics</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span>
        <span class="n">save_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">resume</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate lensed GW source parameters.</span>

<span class="sd">        This function calls the lensed_sampling_routine function to generate</span>
<span class="sd">        the parameters in batches. The generated parameters are stored in a JSON</span>
<span class="sd">        file; and if save_batch=True, it keeps updating the file in batches.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : ``int``</span>
<span class="sd">            Number of samples to generate. \n</span>
<span class="sd">            default: 100000</span>
<span class="sd">        batch_size : ``int``</span>
<span class="sd">            Batch size for sampling. \n</span>
<span class="sd">            default: 50000</span>
<span class="sd">        save_batch : ``bool``</span>
<span class="sd">            If True, saves parameters in batches during sampling. \n</span>
<span class="sd">            If False, saves all parameters at the end (faster). \n</span>
<span class="sd">            default: True</span>
<span class="sd">        resume : ``bool``</span>
<span class="sd">            If True, the function will resume from the last batch. \n</span>
<span class="sd">            default: True</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            JSON file name for storing the parameters. \n</span>
<span class="sd">            default: None (uses self.json_file_names[&quot;lensed_param&quot;])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lensed_param : ``dict``</span>
<span class="sd">            Dictionary of lensed GW source parameters. The included parameters and their units are as follows (for default settings):\n</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | Parameter                    | Units     | Description                                           |</span>
<span class="sd">            +==============================+===========+=======================================================+</span>
<span class="sd">            | zl                           |           | redshift of the lens                                  |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | zs                           |           | redshift of the source                                |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | sigma                        | km s^-1   | velocity dispersion                                   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | q                            |           | axis ratio                                            |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | theta_E                      | radian    | Einstein radius                                       |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | phi                          | rad       | axis rotation angle. counter-clockwise from the       |</span>
<span class="sd">            |                              |           | positive x-axis (RA-like axis) to the major axis of   |</span>
<span class="sd">            |                              |           | the projected mass distribution.                      |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | gamma                        |           | density profile slope of EPL galaxy                   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | gamma1                       |           | external shear component in the x-direction           |</span>
<span class="sd">            |                              |           | (RA-like axis)                                        |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | gamma2                       |           | external shear component in the y-direction           |</span>
<span class="sd">            |                              |           | (Dec-like axis)                                       |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | geocent_time                 | s         | geocent time                                          |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | ra                           | rad       | right ascension                                       |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | dec                          | rad       | declination                                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | phase                        | rad       | phase of GW at reference freq                         |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | psi                          | rad       | polarization angle                                    |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | theta_jn                     | rad       | inclination angle                                     |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | a_1                          |           | spin of the primary compact binary                    |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | a_2                          |           | spin of the secondary compact binary                  |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | luminosity_distance          | Mpc       | luminosity distance of the source                      |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | mass_1_source                | Msun      | mass of the primary compact binary (source frame)     |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | mass_2_source                | Msun      | mass of the secondary compact binary (source frame)   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | mass_1                       | Msun      | mass of the primary compact binary (detector frame)   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | mass_2                       | Msun      | mass of the secondary compact binary (detector frame) |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | x0_image_positions           | radian    | x-coordinate (RA-like axis) of the images             |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | x1_image_positions           | radian    | y-coordinate (Dec-like axis) of the images            |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | magnifications               |           | magnifications                                        |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | time_delays                  |           | time delays                                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | image_type                   |           | image type                                            |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | n_images                     |           | number of images                                      |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | x_source                     | radian    | x-coordinate (RA-like axis) of the source             |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | y_source                     | radian    | y-coordinate (Dec-like axis) of the source            |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_luminosity_distance| Mpc       | effective luminosity distance of the images           |</span>
<span class="sd">            |                              |           | luminosity_distance / sqrt(|magnifications_i|)        |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_geocent_time       | s         | effective GPS time of coalescence of the images       |</span>
<span class="sd">            |                              |           | geocent_time + time_delays_i                          |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_phase              | rad       | morse-phase-corrected phase                           |</span>
<span class="sd">            |                              |           | phi - morse_phase_i                                   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_ra                 | rad       | RA of the image                                       |</span>
<span class="sd">            |                              |           | ra + (x0_image_positions_i - x_source)/cos(dec)       |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_dec                | rad       | Dec of the image                                      |</span>
<span class="sd">            |                              |           | dec + (x1_image_positions_i - y_source)               |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_geocent_time       | s         | effective GPS time of coalescence of the images       |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | pdet_L1                      |           | detection probability of L1                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | pdet_H1                      |           | detection probability of H1                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | pdet_V1                      |           | detection probability of V1                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | pdet_net                     |           | detection probability of the network                  |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; lensed_param = ler.lensed_cbc_statistics()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Note: size must be provided as argument, no default fallback</span>
        <span class="n">output_jsonfile</span> <span class="o">=</span> <span class="n">output_jsonfile</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;lensed_param&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;lensed_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_jsonfile</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lensed params will be stored in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">lensed_param</span> <span class="o">=</span> <span class="n">batch_handler</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">sampling_routine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lensed_sampling_routine</span><span class="p">,</span>
            <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">output_path</span><span class="p">,</span>
            <span class="n">save_batch</span><span class="o">=</span><span class="n">save_batch</span><span class="p">,</span>
            <span class="n">resume</span><span class="o">=</span><span class="n">resume</span><span class="p">,</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;lensed parameters&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">lensed_param</span></div>


<div class="viewcode-block" id="LeR.lensed_sampling_routine">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.lensed_sampling_routine">[docs]</a>
    <span class="k">def</span> <span class="nf">lensed_sampling_routine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">save_batch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate lensed GW source parameters for a single batch.</span>

<span class="sd">        This is the core sampling routine called by lensed_cbc_statistics.</span>
<span class="sd">        It samples lens parameters, calculates image properties, and computes</span>
<span class="sd">        detection probabilities for the images of lensed events.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : ``int``</span>
<span class="sd">            Number of samples to generate.</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            JSON file name for storing the parameters.</span>
<span class="sd">        save_batch : ``bool``</span>
<span class="sd">            If True, saves parameters in batches during sampling. \n</span>
<span class="sd">            default: True</span>
<span class="sd">        resume : ``bool``</span>
<span class="sd">            If True, appends new samples to existing JSON file. \n</span>
<span class="sd">            default: True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lensed_param : ``dict``</span>
<span class="sd">            Dictionary of lensed GW source parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sampling lensed params...&quot;</span><span class="p">)</span>
        <span class="n">lensed_param</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Some of the sample lensed events may not satisfy the strong lensing condition</span>
        <span class="c1"># In that case, we will resample those events and replace the values with the corresponding indices</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># get lensed params</span>
            <span class="n">lensed_param_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_lens_parameters</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
            <span class="c1"># now get (strongly lensed) image paramters along with lens parameters</span>
            <span class="n">lensed_param_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_properties</span><span class="p">(</span><span class="n">lensed_param_</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if empty</span>
                <span class="n">lensed_param</span> <span class="o">=</span> <span class="n">lensed_param_</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># below will not be used in the first iteration</span>
                <span class="c1"># replace the values of the keys</span>
                <span class="c1"># idx defines the position that does not satisfy the strong lensing condition</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lensed_param_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">lensed_param</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># noqa: F821</span>

            <span class="c1"># check for invalid samples</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;n_images&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_min_images</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span>
                <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;n_images&quot;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_max_images</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid sample found. Resampling </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="si">}</span><span class="s2"> lensed events...&quot;</span>
                <span class="p">)</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating pdet...&quot;</span><span class="p">)</span>
        <span class="n">pdet</span><span class="p">,</span> <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lensed_snrs</span><span class="p">(</span>
            <span class="n">lensed_param</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span>
            <span class="n">pdet_finder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdet_finder</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">lensed_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pdet</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lensed_param</span></div>


<div class="viewcode-block" id="LeR.lensed_rate">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.lensed_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">lensed_rate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lensed_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pdet_threshold</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
        <span class="n">num_img</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pdet_type</span><span class="o">=</span><span class="s2">&quot;boolean&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate the lensed rate.</span>

<span class="sd">        This function calculates the detection rate for lensed events and stores</span>
<span class="sd">        the parameters of the detectable events in a JSON file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : ``dict`` or ``str``</span>
<span class="sd">            Dictionary of lensed GW source parameters or JSON file name. \n</span>
<span class="sd">            default: None (uses self.json_file_names[&quot;lensed_param&quot;])</span>
<span class="sd">        pdet_threshold : ``float`` or ``list``</span>
<span class="sd">            Threshold for detection probability. \n</span>
<span class="sd">            default: [0.5, 0.5]</span>
<span class="sd">        num_img : ``int`` or ``list``</span>
<span class="sd">            Number of images corresponding to the pdet_threshold. \n</span>
<span class="sd">            Together with pdet_threshold = [0.5, 0.5], it means that two images with pdet &gt; 0.5. \n</span>
<span class="sd">            Same condition can also be represented by pdet_threshold = 0.5 and num_img = 2. \n</span>
<span class="sd">            default: [1, 1]</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            JSON file name for storing the parameters of the detectable events. \n</span>
<span class="sd">            default: None (uses self.json_file_names[&quot;lensed_param_detectable&quot;])</span>
<span class="sd">        nan_to_num : ``bool``</span>
<span class="sd">            If True, NaN values will be converted to 0. \n</span>
<span class="sd">            default: True</span>
<span class="sd">        pdet_type : ``str``</span>
<span class="sd">            Detectability condition type. \n</span>
<span class="sd">            Options: \n</span>
<span class="sd">            - &#39;boolean&#39;: Binary detection based on pdet_threshold \n</span>
<span class="sd">            - &#39;probability_distribution&#39;: Uses pdet values directly \n</span>
<span class="sd">            default: &#39;boolean&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_rate : ``float``</span>
<span class="sd">            Total lensed rate (yr^-1).</span>
<span class="sd">        lensed_param : ``dict``</span>
<span class="sd">            Dictionary of lensed GW source parameters of the detectable events. The included parameters and their units are as follows (for default settings):\n</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | Parameter                    | Units     | Description                                           |</span>
<span class="sd">            +==============================+===========+=======================================================+</span>
<span class="sd">            | zl                           |           | redshift of the lens                                  |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | zs                           |           | redshift of the source                                |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | sigma                        | km s^-1   | velocity dispersion                                   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | q                            |           | axis ratio                                            |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | theta_E                      | radian    | Einstein radius                                       |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | phi                          | rad       | axis rotation angle. counter-clockwise from the       |</span>
<span class="sd">            |                              |           | positive x-axis (RA-like axis) to the major axis of   |</span>
<span class="sd">            |                              |           | the projected mass distribution.                      |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | gamma                        |           | density profile slope of EPL galaxy                   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | gamma1                       |           | external shear component in the x-direction           |</span>
<span class="sd">            |                              |           | (RA-like axis)                                        |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | gamma2                       |           | external shear component in the y-direction           |</span>
<span class="sd">            |                              |           | (Dec-like axis)                                       |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | geocent_time                 | s         | geocent time                                          |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | ra                           | rad       | right ascension                                       |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | dec                          | rad       | declination                                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | phase                        | rad       | phase of GW at reference freq                         |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | psi                          | rad       | polarization angle                                    |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | theta_jn                     | rad       | inclination angle                                     |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | a_1                          |           | spin of the primary compact binary                    |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | a_2                          |           | spin of the secondary compact binary                  |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | luminosity_distance          | Mpc       | luminosity distance of the source                      |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | mass_1_source                | Msun      | mass of the primary compact binary (source frame)     |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | mass_2_source                | Msun      | mass of the secondary compact binary (source frame)   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | mass_1                       | Msun      | mass of the primary compact binary (detector frame)   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | mass_2                       | Msun      | mass of the secondary compact binary (detector frame) |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | x0_image_positions           | radian    | x-coordinate (RA-like axis) of the images             |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | x1_image_positions           | radian    | y-coordinate (Dec-like axis) of the images            |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | magnifications               |           | magnifications                                        |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | time_delays                  |           | time delays                                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | image_type                   |           | image type                                            |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | n_images                     |           | number of images                                      |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | x_source                     | radian    | x-coordinate (RA-like axis) of the source             |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | y_source                     | radian    | y-coordinate (Dec-like axis) of the source            |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_luminosity_distance| Mpc       | effective luminosity distance of the images           |</span>
<span class="sd">            |                              |           | luminosity_distance / sqrt(|magnifications_i|)        |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_geocent_time       | s         | effective GPS time of coalescence of the images       |</span>
<span class="sd">            |                              |           | geocent_time + time_delays_i                          |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_phase              | rad       | morse-phase-corrected phase                           |</span>
<span class="sd">            |                              |           | phi - morse_phase_i                                   |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_ra                 | rad       | RA of the image                                       |</span>
<span class="sd">            |                              |           | ra + (x0_image_positions_i - x_source)/cos(dec)       |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | effective_dec                | rad       | Dec of the image                                      |</span>
<span class="sd">            |                              |           | dec + (x1_image_positions_i - y_source)               |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | pdet_L1                      |           | detection probability of L1                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | pdet_H1                      |           | detection probability of H1                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | pdet_V1                      |           | detection probability of V1                           |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>
<span class="sd">            | pdet_net                     |           | detection probability of the network                  |</span>
<span class="sd">            +------------------------------+-----------+-------------------------------------------------------+</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; ler.lensed_cbc_statistics()</span>
<span class="sd">        &gt;&gt;&gt; total_rate, lensed_param_detectable = ler.lensed_rate()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># load lensed parameters</span>
        <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_param</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span><span class="p">)</span>

        <span class="c1"># re-analyse the provided pdet_threshold and num_img</span>
        <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_pdet_threshold_lensed</span><span class="p">(</span>
            <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span>
        <span class="p">)</span>

        <span class="c1"># get size of the lensed_param for a parameter</span>
        <span class="n">total_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>

        <span class="c1"># find index of detectable events</span>
        <span class="n">pdet_hit</span><span class="p">,</span> <span class="n">pdet_prod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_detectable_index_lensed</span><span class="p">(</span>
            <span class="n">lensed_param</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">,</span> <span class="n">pdet_type</span>
        <span class="p">)</span>

        <span class="c1"># montecarlo integration</span>
        <span class="n">pdet_processed</span> <span class="o">=</span> <span class="n">pdet_hit</span> <span class="k">if</span> <span class="n">pdet_type</span> <span class="o">==</span> <span class="s2">&quot;boolean&quot;</span> <span class="k">else</span> <span class="n">pdet_prod</span>
        <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pdet_processed</span><span class="p">),</span> <span class="n">total_events</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span>
        <span class="p">)</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_detectable_params</span><span class="p">(</span>
            <span class="n">output_jsonfile</span><span class="p">,</span>
            <span class="n">lensed_param</span><span class="p">,</span>
            <span class="n">pdet_hit</span><span class="p">,</span>
            <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;lensed_param_detectable&quot;</span><span class="p">,</span>
            <span class="n">nan_to_num</span><span class="o">=</span><span class="n">nan_to_num</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># append ler_param and save it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_ler_param</span><span class="p">(</span><span class="n">total_rate</span><span class="p">,</span> <span class="n">pdet_type</span><span class="o">=</span><span class="n">pdet_type</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">total_rate</span><span class="p">,</span> <span class="n">lensed_param</span></div>


    <span class="k">def</span> <span class="nf">_check_pdet_threshold_lensed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to check the pdet_threshold and num_img for lensed events.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pdet_threshold : ``float``</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            default pdet_threshold = [0.5,0.5].</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images corresponding to the pdet_threshold.</span>
<span class="sd">            default num_img = [1,1]. Together with pdet_threshold = [0.5,0.5], it means that two images with pdet&gt;0.5. Same condition can also be represented by pdet_threshold = 0.5 and num_img = 2.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        pdet_threshold : ``float``</span>
<span class="sd">            threshold for detection probability.</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images corresponding to the snr_threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check for images with snr above threshold</span>
        <span class="c1"># convert to array</span>
        <span class="n">pdet_threshold_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pdet_threshold</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">num_img_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">num_img</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># get descending sorted idx of snr_threshold</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">pdet_threshold_</span><span class="p">)</span>
        <span class="n">pdet_threshold</span> <span class="o">=</span> <span class="n">pdet_threshold_</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">num_img</span> <span class="o">=</span> <span class="n">num_img_</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span>

    <span class="k">def</span> <span class="nf">_find_detectable_index_lensed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">lensed_param</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">,</span> <span class="n">pdet_type</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to find the index of detectable events based on SNR or p_det.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : ``dict``</span>
<span class="sd">            dictionary of lensed GW source parameters.</span>
<span class="sd">        pdet_threshold : ``float`` or ``list``</span>
<span class="sd">            threshold for detection probability.</span>
<span class="sd">            default pdet_threshold = 0.5.</span>
<span class="sd">        num_img : ``int`` or ``list``</span>
<span class="sd">            number of images corresponding to the pdet_threshold.</span>
<span class="sd">            default num_img = [1,1].</span>
<span class="sd">        pdet_type : ``str``</span>
<span class="sd">            detectability condition.</span>
<span class="sd">            default pdet_type = &#39;boolean&#39;.</span>
<span class="sd">            other options are &#39;pdet&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        pdet_hit : ``bool``</span>
<span class="sd">            boolean array to store the result of the threshold condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;pdet_net&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lensed_param</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;pdet_net&#39; not in lensed parm dict provided&quot;</span><span class="p">)</span>

        <span class="c1"># print(f&quot;given pdet_type == {pdet_type}&quot;)</span>
        <span class="k">if</span> <span class="n">pdet_type</span> <span class="o">==</span> <span class="s2">&quot;boolean&quot;</span><span class="p">:</span>

            <span class="n">pdet_param</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span>
            <span class="n">pdet_param</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">pdet_param</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sort pdet in descending order</span>
            <span class="n">pdet_hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">pdet_param</span><span class="p">),</span> <span class="kc">True</span>
            <span class="p">)</span>  <span class="c1"># boolean array to store the result of the threshold condition</span>

            <span class="c1"># for each row: choose a threshold and check if the number of images above threshold. Sum over the images. If sum is greater than num_img, then snr_hit = True</span>
            <span class="c1"># algorithm:</span>
            <span class="c1"># i) consider pdet_threshold=[0.5,0.5] and num_img=[2,1] and first row of pdet_param[0]=[0.6,0.4,0.3,0.2]. Note that the pdet_param is sorted in descending order.</span>
            <span class="c1"># ii) for loop runs wrt pdet_threshold. idx_max = idx_max + num_img[i]</span>
            <span class="c1"># iii) First iteration: pdet_threshold=0.5 and num_img=2. In pdet_param, column index 0 and 1 (i.e. 0:num_img[0]) are considered. The sum of pdet_param[0, 0:2] &gt; 0.5 is checked. If True, then pdet_hit = True.</span>
            <span class="c1"># v) Second iteration: pdet_threshold=0.5 and num_img=1. In pdet_param, column index 2 (i.e. num_img[0]:num_img[1]) is considered. The sum of pdet_param[0, 0:1] &gt; 0.5 is checked. If True, then pdet_hit = True.</span>
            <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idx_max</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pdet_th</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pdet_threshold</span><span class="p">):</span>
                <span class="n">idx_max</span> <span class="o">=</span> <span class="n">idx_max</span> <span class="o">+</span> <span class="n">num_img</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">pdet_hit</span> <span class="o">=</span> <span class="n">pdet_hit</span> <span class="o">&amp;</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pdet_param</span><span class="p">[:,</span> <span class="n">j</span><span class="p">:</span><span class="n">idx_max</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pdet_th</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">num_img</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="c1"># select according to time delays</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">idx_max</span>

            <span class="n">pdet_prod</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">pdet_type</span> <span class="o">==</span> <span class="s2">&quot;probability_distribution&quot;</span><span class="p">:</span>

            <span class="n">pdet</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span>
            <span class="c1"># sort pdet in descending order</span>
            <span class="n">pdet</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">pdet</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># column index beyong np.sum(num_img)-1 are not considered</span>
            <span class="n">pdet</span> <span class="o">=</span> <span class="n">pdet</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">num_img</span><span class="p">)]</span>

            <span class="n">pdet_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">pdet</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">pdet_hit</span> <span class="o">=</span> <span class="n">pdet_prod</span> <span class="o">&gt;=</span> <span class="n">pdet_threshold</span>


        <span class="k">return</span> <span class="n">pdet_hit</span><span class="p">,</span> <span class="n">pdet_prod</span>

<div class="viewcode-block" id="LeR.rate_comparison_with_rate_calculation">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.rate_comparison_with_rate_calculation">[docs]</a>
    <span class="k">def</span> <span class="nf">rate_comparison_with_rate_calculation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">unlensed_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pdet_threshold_unlensed</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">output_jsonfile_unlensed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lensed_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pdet_threshold_lensed</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
        <span class="n">num_img_lensed</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">output_jsonfile_lensed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pdet_type</span><span class="o">=</span><span class="s2">&quot;boolean&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and compare unlensed and lensed detection rates.</span>

<span class="sd">        This function calculates both unlensed and lensed rates and computes</span>
<span class="sd">        their ratio. It stores the parameters of the detectable events in JSON</span>
<span class="sd">        files. Using this function eliminates the need to call unlensed_rate</span>
<span class="sd">        and lensed_rate separately.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param : ``dict`` or ``str``</span>
<span class="sd">            Dictionary of GW source parameters or JSON file name. \n</span>
<span class="sd">            default: None (uses self.json_file_names[&quot;unlensed_param&quot;])</span>
<span class="sd">        pdet_threshold_unlensed : ``float``</span>
<span class="sd">            Detection probability threshold for unlensed events. \n</span>
<span class="sd">            default: 0.5</span>
<span class="sd">        output_jsonfile_unlensed : ``str``</span>
<span class="sd">            JSON file name for storing detectable unlensed parameters. \n</span>
<span class="sd">            default: None</span>
<span class="sd">        lensed_param : ``dict`` or ``str``</span>
<span class="sd">            Dictionary of lensed GW source parameters or JSON file name. \n</span>
<span class="sd">            default: None (uses self.json_file_names[&quot;lensed_param&quot;])</span>
<span class="sd">        pdet_threshold_lensed : ``float`` or ``list``</span>
<span class="sd">            Detection probability threshold for lensed events. \n</span>
<span class="sd">            default: [0.5, 0.5]</span>
<span class="sd">        num_img_lensed : ``list``</span>
<span class="sd">            Number of images for lensed events. \n</span>
<span class="sd">            default: [1, 1]</span>
<span class="sd">        output_jsonfile_lensed : ``str``</span>
<span class="sd">            JSON file name for storing detectable lensed parameters. \n</span>
<span class="sd">            default: None</span>
<span class="sd">        nan_to_num : ``bool``</span>
<span class="sd">            If True, NaN values will be converted to 0. \n</span>
<span class="sd">            default: True</span>
<span class="sd">        pdet_type : ``str``</span>
<span class="sd">            Detectability condition type. \n</span>
<span class="sd">            Options: \n</span>
<span class="sd">            - &#39;boolean&#39;: Binary detection based on pdet_threshold \n</span>
<span class="sd">            - &#39;probability_distribution&#39;: Uses pdet values directly \n</span>
<span class="sd">            default: &#39;boolean&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rate_ratio : ``float``</span>
<span class="sd">            Ratio of unlensed rate to lensed rate.</span>
<span class="sd">        unlensed_param_detectable : ``dict``</span>
<span class="sd">            Dictionary of detectable unlensed GW source parameters.</span>
<span class="sd">        lensed_param_detectable : ``dict``</span>
<span class="sd">            Dictionary of detectable lensed GW source parameters.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; ler.unlensed_cbc_statistics()</span>
<span class="sd">        &gt;&gt;&gt; ler.lensed_cbc_statistics()</span>
<span class="sd">        &gt;&gt;&gt; rate_ratio, unlensed_param, lensed_param = ler.rate_comparison_with_rate_calculation()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get unlensed rate</span>
        <span class="n">unlensed_rate</span><span class="p">,</span> <span class="n">unlensed_param_detectable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unlensed_rate</span><span class="p">(</span>
            <span class="n">unlensed_param</span><span class="o">=</span><span class="n">unlensed_param</span><span class="p">,</span>
            <span class="n">pdet_threshold</span><span class="o">=</span><span class="n">pdet_threshold_unlensed</span><span class="p">,</span>
            <span class="n">pdet_type</span><span class="o">=</span><span class="n">pdet_type</span><span class="p">,</span>
            <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">output_jsonfile_unlensed</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># get lensed rate</span>
        <span class="n">lensed_rate</span><span class="p">,</span> <span class="n">lensed_param_detectable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lensed_rate</span><span class="p">(</span>
            <span class="n">lensed_param</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span>
            <span class="n">pdet_threshold</span><span class="o">=</span><span class="n">pdet_threshold_lensed</span><span class="p">,</span>
            <span class="n">num_img</span><span class="o">=</span><span class="n">num_img_lensed</span><span class="p">,</span>
            <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">output_jsonfile_lensed</span><span class="p">,</span>
            <span class="n">nan_to_num</span><span class="o">=</span><span class="n">nan_to_num</span><span class="p">,</span>
            <span class="n">pdet_type</span><span class="o">=</span><span class="n">pdet_type</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># calculate rate ratio</span>
        <span class="n">rate_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_ratio</span><span class="p">()</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">unlensed_rate</span><span class="p">,</span>
            <span class="n">lensed_rate</span><span class="p">,</span>
            <span class="n">rate_ratio</span><span class="p">,</span>
            <span class="n">unlensed_param_detectable</span><span class="p">,</span>
            <span class="n">lensed_param_detectable</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="LeR.rate_ratio">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.rate_ratio">[docs]</a>
    <span class="k">def</span> <span class="nf">rate_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and display the unlensed to lensed merger rate ratio.</span>

<span class="sd">        This function retrieves the unlensed_rate and lensed_rate from the</span>
<span class="sd">        JSON file specified in self.json_file_names[&quot;ler_params&quot;] and computes</span>
<span class="sd">        their ratio.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rate_ratio : ``float``</span>
<span class="sd">            Ratio of unlensed rate to lensed rate.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; ler.unlensed_cbc_statistics()</span>
<span class="sd">        &gt;&gt;&gt; ler.lensed_cbc_statistics()</span>
<span class="sd">        &gt;&gt;&gt; ler.unlensed_rate()</span>
<span class="sd">        &gt;&gt;&gt; ler.lensed_rate()</span>
<span class="sd">        &gt;&gt;&gt; ler.rate_ratio()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call json_file_ler_param and add the results</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">unlensed_rate</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_unlensed_rate_per_year&quot;</span><span class="p">]</span>
            <span class="n">lensed_rate</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_lensed_rate_per_year&quot;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;detectable_unlensed_rate_per_year or &#39;detectable_lensed_rate_per_year&#39; not found in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s1">&#39;ler_params&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> json file. </span><span class="se">\n</span><span class="s2">Run the functions &#39;unlensed_rate&#39; and &#39;lensed_rate&#39; to calculate and save the rates.&quot;</span>
            <span class="p">)</span>

        <span class="n">rate_ratio</span> <span class="o">=</span> <span class="n">unlensed_rate</span> <span class="o">/</span> <span class="n">lensed_rate</span>
        <span class="c1"># append the results</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;rate_ratio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate_ratio</span>
        <span class="c1"># write the results</span>
        <span class="n">append_json</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">],</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unlensed_rate: </span><span class="si">{</span><span class="n">unlensed_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lensed_rate: </span><span class="si">{</span><span class="n">lensed_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ratio: </span><span class="si">{</span><span class="n">rate_ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unlensed_rate</span> <span class="o">/</span> <span class="n">lensed_rate</span></div>


<div class="viewcode-block" id="LeR.selecting_n_unlensed_detectable_events">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.selecting_n_unlensed_detectable_events">[docs]</a>
    <span class="k">def</span> <span class="nf">selecting_n_unlensed_detectable_events</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span>
        <span class="n">stopping_criteria</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">relative_diff_percentage</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">number_of_last_batches_to_check</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">pdet_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">resume</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="s2">&quot;n_unlensed_param_detectable.json&quot;</span><span class="p">,</span>
        <span class="n">meta_data_file</span><span class="o">=</span><span class="s2">&quot;meta_unlensed.json&quot;</span><span class="p">,</span>
        <span class="n">pdet_type</span><span class="o">=</span><span class="s2">&quot;boolean&quot;</span><span class="p">,</span>
        <span class="n">trim_to_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a target number of detectable unlensed events by sampling in batches, with the option to stop once the cumulative rate has stabilized.</span>

<span class="sd">        This function samples unlensed parameters and saves only the detectable</span>
<span class="sd">        events in a JSON file. It also records metadata including the total</span>
<span class="sd">        number of events and the cumulative rate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : ``int``</span>
<span class="sd">            Target number of detectable samples to collect. \n</span>
<span class="sd">            default: 100</span>
<span class="sd">        batch_size : ``int``</span>
<span class="sd">            Batch size for sampling. \n</span>
<span class="sd">            default: 50000</span>
<span class="sd">        stopping_criteria : ``dict`` or ``None``</span>
<span class="sd">            Criteria for stopping sample collection (but will not stop until n&gt;size). \n</span>
<span class="sd">            Keys: \n</span>
<span class="sd">            - &#39;relative_diff_percentage&#39;: Maximum relative difference in rate (float) \n</span>
<span class="sd">            - &#39;number_of_last_batches_to_check&#39;: Number of batches for comparison (int) \n</span>
<span class="sd">            If None, stops when detectable events exceed size. \n</span>
<span class="sd">            default: dict(relative_diff_percentage=0.5, number_of_last_batches_to_check=4)</span>
<span class="sd">        pdet_threshold : ``float``</span>
<span class="sd">            Detection probability threshold. \n</span>
<span class="sd">            default: 0.5</span>
<span class="sd">        resume : ``bool``</span>
<span class="sd">            If True, resumes from last saved batch. \n</span>
<span class="sd">            default: True</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            JSON file name for storing detectable parameters. \n</span>
<span class="sd">            default: &#39;n_unlensed_param_detectable.json&#39;</span>
<span class="sd">        meta_data_file : ``str``</span>
<span class="sd">            JSON file name for storing metadata. \n</span>
<span class="sd">            default: &#39;meta_unlensed.json&#39;</span>
<span class="sd">        pdet_type : ``str``</span>
<span class="sd">            Detectability condition type. \n</span>
<span class="sd">            Options: \n</span>
<span class="sd">            - &#39;boolean&#39;: Binary detection based on pdet_threshold \n</span>
<span class="sd">            - &#39;probability_distribution&#39;: Uses pdet values directly \n</span>
<span class="sd">            default: &#39;boolean&#39;</span>
<span class="sd">        trim_to_size : ``bool``</span>
<span class="sd">            If True, trims final result to exactly size events. \n</span>
<span class="sd">            default: False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        param_final : ``dict``</span>
<span class="sd">            Dictionary of unlensed GW source parameters of detectable events.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; unlensed_param = ler.selecting_n_unlensed_detectable_events(size=100)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">stopping_criteria</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;stopping criteria set to when relative difference of total rate for the last </span><span class="si">{</span><span class="n">stopping_criteria</span><span class="p">[</span><span class="s1">&#39;number_of_last_batches_to_check&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> cumulative batches is less than </span><span class="si">{</span><span class="n">stopping_criteria</span><span class="p">[</span><span class="s1">&#39;relative_diff_percentage&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">%.&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;sample collection will stop when the stopping criteria is met and number of detectable events exceeds the specified size.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;stopping criteria not set. sample collection will stop when number of detectable events exceeds the specified size.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># initial setup</span>
        <span class="p">(</span>
            <span class="n">n</span><span class="p">,</span>
            <span class="n">events_total</span><span class="p">,</span>
            <span class="n">output_path</span><span class="p">,</span>
            <span class="n">meta_data_path</span><span class="p">,</span>
            <span class="n">buffer_file</span><span class="p">,</span>
            <span class="n">continue_condition</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_setup_for_n_event_selection</span><span class="p">(</span>
            <span class="n">size</span><span class="p">,</span> <span class="n">meta_data_file</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">resume</span><span class="p">,</span> <span class="n">stopping_criteria</span>
        <span class="p">)</span>

        <span class="c1"># loop until n==size samples are collected</span>
        <span class="k">while</span> <span class="n">continue_condition</span><span class="p">:</span>
            <span class="c1"># disable print statements</span>
            <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict_buffer</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># this is used to store the sampled unlensed_param in batches when running the sampling_routine</span>
                <span class="n">unlensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unlensed_sampling_routine</span><span class="p">(</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span>
                    <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">buffer_file</span><span class="p">,</span>
                    <span class="n">save_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">total_events_in_this_iteration</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>
            <span class="c1"># below is use when the snr is calculated with &#39;ann&#39; method of `gwsnr`</span>

            <span class="c1"># find index of detectable events</span>
            <span class="n">pdet</span> <span class="o">=</span> <span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span>
            <span class="n">idx_detectable</span> <span class="o">=</span> <span class="n">pdet</span> <span class="o">&gt;</span> <span class="n">pdet_threshold</span>

            <span class="c1"># store all params in json file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_detectable_params</span><span class="p">(</span>
                <span class="n">output_jsonfile</span><span class="p">,</span>
                <span class="n">unlensed_param</span><span class="p">,</span>
                <span class="n">idx_detectable</span><span class="p">,</span>
                <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;n_unlensed_detectable_events&quot;</span><span class="p">,</span>
                <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">pdet_type</span> <span class="o">==</span> <span class="s2">&quot;boolean&quot;</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx_detectable</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pdet</span><span class="p">)</span>
            <span class="n">events_total</span> <span class="o">+=</span> <span class="n">total_events_in_this_iteration</span>
            <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span>
                <span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="c1"># bookmark</span>
            <span class="n">buffer_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_meta_data</span><span class="p">(</span>
                <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">total_rate</span>
            <span class="p">)</span>

            <span class="n">continue_condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_continue_condition_check</span><span class="p">(</span>
                <span class="n">size</span><span class="p">,</span>
                <span class="n">buffer_dict</span><span class="p">,</span>
                <span class="n">stopping_criteria</span><span class="p">,</span>
                <span class="n">initial_continue_condition</span><span class="o">=</span><span class="n">continue_condition</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;stored detectable unlensed params in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;stored meta data in </span><span class="si">{</span><span class="n">meta_data_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">trim_to_size</span><span class="p">:</span>
            <span class="n">param_final</span><span class="p">,</span> <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim_results_to_size</span><span class="p">(</span>
                <span class="n">size</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">meta_data_path</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="n">meta_data</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
            <span class="n">total_rate</span> <span class="o">=</span> <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;total_rate&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># call self.json_file_names[&quot;ler_param&quot;] and for adding the final results</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>
        <span class="c1"># write the results</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_unlensed_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pdet_type_unlensed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdet_type</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_unlensed_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;total_rate&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pdet_type_unlensed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdet_type</span>

        <span class="n">append_json</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">],</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">total_rate</span><span class="p">,</span><span class="n">param_final</span></div>


<div class="viewcode-block" id="LeR.selecting_n_lensed_detectable_events">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.selecting_n_lensed_detectable_events">[docs]</a>
    <span class="k">def</span> <span class="nf">selecting_n_lensed_detectable_events</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">stopping_criteria</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">relative_diff_percentage</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">number_of_last_batches_to_check</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span>
        <span class="n">pdet_threshold</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span>
        <span class="n">num_img</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
        <span class="n">resume</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">pdet_type</span><span class="o">=</span><span class="s2">&quot;boolean&quot;</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="s2">&quot;n_lensed_params_detectable.json&quot;</span><span class="p">,</span>
        <span class="n">meta_data_file</span><span class="o">=</span><span class="s2">&quot;meta_lensed.json&quot;</span><span class="p">,</span>
        <span class="n">trim_to_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a target number of detectable lensed events by sampling in batches, with the option to stop once the cumulative rate has stabilized.</span>

<span class="sd">        This function samples lensed parameters and saves only the detectable</span>
<span class="sd">        events in a JSON file. It also records metadata including the total</span>
<span class="sd">        number of events and the cumulative rate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : ``int``</span>
<span class="sd">            Target number of detectable samples to collect. \n</span>
<span class="sd">            default: 100</span>
<span class="sd">        stopping_criteria : ``dict`` or ``None``</span>
<span class="sd">            Criteria for stopping sample collection (but will not stop until n&gt;size). \n</span>
<span class="sd">            Keys: \n</span>
<span class="sd">            - &#39;relative_diff_percentage&#39;: Maximum relative difference in rate (float) \n</span>
<span class="sd">            - &#39;number_of_last_batches_to_check&#39;: Number of batches for comparison (int) \n</span>
<span class="sd">            If None, stops when detectable events exceed size. \n</span>
<span class="sd">            default: dict(relative_diff_percentage=2, number_of_last_batches_to_check=4)</span>
<span class="sd">        batch_size : ``int``</span>
<span class="sd">            Batch size for sampling. \n</span>
<span class="sd">            default: 50000</span>
<span class="sd">        pdet_threshold : ``float`` or ``list``</span>
<span class="sd">            Detection probability threshold. \n</span>
<span class="sd">            default: [0.5, 0.5]</span>
<span class="sd">        num_img : ``list``</span>
<span class="sd">            Number of images corresponding to each pdet_threshold. \n</span>
<span class="sd">            default: [1, 1]</span>
<span class="sd">        resume : ``bool``</span>
<span class="sd">            If True, resumes from last saved batch. \n</span>
<span class="sd">            default: True</span>
<span class="sd">        pdet_type : ``str``</span>
<span class="sd">            Detectability condition type. \n</span>
<span class="sd">            Options: \n</span>
<span class="sd">            - &#39;boolean&#39;: Binary detection based on pdet_threshold \n</span>
<span class="sd">            - &#39;probability_distribution&#39;: Uses pdet values directly \n</span>
<span class="sd">            default: &#39;boolean&#39;</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            JSON file name for storing detectable parameters. \n</span>
<span class="sd">            default: &#39;n_lensed_params_detectable.json&#39;</span>
<span class="sd">        meta_data_file : ``str``</span>
<span class="sd">            JSON file name for storing metadata. \n</span>
<span class="sd">            default: &#39;meta_lensed.json&#39;</span>
<span class="sd">        trim_to_size : ``bool``</span>
<span class="sd">            If True, trims final result to exactly size events. \n</span>
<span class="sd">            default: False</span>
<span class="sd">        nan_to_num : ``bool``</span>
<span class="sd">            If True, NaN values will be converted to 0. \n</span>
<span class="sd">            default: False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        param_final : ``dict``</span>
<span class="sd">            Dictionary of lensed GW source parameters of detectable events.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from ler import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; lensed_param = ler.selecting_n_lensed_detectable_events(size=100)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">stopping_criteria</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;stopping criteria set to when relative difference of total rate for the last </span><span class="si">{</span><span class="n">stopping_criteria</span><span class="p">[</span><span class="s1">&#39;number_of_last_batches_to_check&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> cumulative batches is less than </span><span class="si">{</span><span class="n">stopping_criteria</span><span class="p">[</span><span class="s1">&#39;relative_diff_percentage&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">%.&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;sample collection will stop when the stopping criteria is met and number of detectable events exceeds the specified size.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot;stopping criteria not set. sample collection will stop when number of detectable events exceeds the specified size.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># initial setup</span>
        <span class="p">(</span>
            <span class="n">n_cumulative</span><span class="p">,</span>
            <span class="n">events_total</span><span class="p">,</span>
            <span class="n">output_path</span><span class="p">,</span>
            <span class="n">meta_data_path</span><span class="p">,</span>
            <span class="n">buffer_file</span><span class="p">,</span>
            <span class="n">continue_condition</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_setup_for_n_event_selection</span><span class="p">(</span>
            <span class="n">size</span><span class="p">,</span> <span class="n">meta_data_file</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">resume</span><span class="p">,</span> <span class="n">stopping_criteria</span>
        <span class="p">)</span>

        <span class="c1"># re-analyse the provided pdet_threshold and num_img</span>
        <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_pdet_threshold_lensed</span><span class="p">(</span>
            <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span>
        <span class="p">)</span>

        <span class="c1"># loop until n==size samples are collected</span>
        <span class="k">while</span> <span class="n">continue_condition</span><span class="p">:</span>
            <span class="c1"># disable print statements</span>
            <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict_buffer</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># this is used to store the sampled lensed_param in batches when running the sampling_routine</span>
                <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lensed_sampling_routine</span><span class="p">(</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">buffer_file</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>  <span class="c1"># Dimensions are (size, n_max_images)</span>

            <span class="n">total_events_in_this_iteration</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>

            <span class="c1"># find index of detectable events</span>
            <span class="n">pdet_hit</span><span class="p">,</span> <span class="n">pdet_prod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_detectable_index_lensed</span><span class="p">(</span>
                <span class="n">lensed_param</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">,</span> <span class="n">pdet_type</span>
            <span class="p">)</span>

            <span class="n">pdet_processed</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">pdet_hit</span> <span class="k">if</span> <span class="n">pdet_type</span> <span class="o">==</span> <span class="s2">&quot;boolean&quot;</span> <span class="k">else</span> <span class="n">pdet_prod</span>
            <span class="p">)</span>

            <span class="c1"># store all params in json file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_detectable_params</span><span class="p">(</span>
                <span class="n">output_jsonfile</span><span class="p">,</span>
                <span class="n">lensed_param</span><span class="p">,</span>
                <span class="n">pdet_hit</span><span class="p">,</span>
                <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;n_lensed_detectable_events&quot;</span><span class="p">,</span>
                <span class="n">nan_to_num</span><span class="o">=</span><span class="n">nan_to_num</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">n_cumulative</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pdet_processed</span><span class="p">)</span>
            <span class="n">events_total</span> <span class="o">+=</span> <span class="n">total_events_in_this_iteration</span>
            <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span>
                <span class="n">n_cumulative</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="c1"># save meta data</span>
            <span class="n">buffer_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_meta_data</span><span class="p">(</span>
                <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">n_cumulative</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">total_rate</span>
            <span class="p">)</span>

            <span class="n">continue_condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_continue_condition_check</span><span class="p">(</span>
                <span class="n">size</span><span class="p">,</span>
                <span class="n">buffer_dict</span><span class="p">,</span>
                <span class="n">stopping_criteria</span><span class="p">,</span>
                <span class="n">initial_continue_condition</span><span class="o">=</span><span class="n">continue_condition</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;storing detectable lensed params in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;storing meta data in </span><span class="si">{</span><span class="n">meta_data_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">trim_to_size</span><span class="p">:</span>
            <span class="n">param_final</span><span class="p">,</span> <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim_results_to_size</span><span class="p">(</span>
                <span class="n">size</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="n">meta_data</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
            <span class="n">total_rate</span> <span class="o">=</span> <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;total_rate&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># call self.json_file_names[&quot;ler_param&quot;] and for adding the final results</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>
        <span class="c1"># write the results</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_lensed_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pdet_type_lensed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdet_type</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_lensed_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;total_rate&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;pdet_type_lensed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pdet_type</span>
        <span class="n">buffer_dict</span> <span class="o">=</span> <span class="n">append_json</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">],</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">total_rate</span><span class="p">,</span> <span class="n">param_final</span></div>


    <span class="k">def</span> <span class="nf">_initial_setup_for_n_event_selection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">meta_data_file</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">resume</span><span class="p">,</span> <span class="n">stopping_criteria</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function for selecting_n_unlensed_detectable_events and selecting_n_lensed_detectable_events functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : `int`</span>
<span class="sd">            number of samples to be collected.</span>
<span class="sd">        meta_data_file : ``str``</span>
<span class="sd">            json file name for storing the metadata.</span>
<span class="sd">        output_jsonfile : ``str``</span>
<span class="sd">            json file name for storing the parameters of the detectable events.</span>
<span class="sd">        resume : ``bool``</span>
<span class="sd">            resume = False (default) or True.</span>
<span class="sd">            if True, the function will resume from the last batch.</span>
<span class="sd">        batch_size : ``int``</span>
<span class="sd">            batch size for sampling.</span>
<span class="sd">            default batch_size = 50000.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        n : ``int``</span>
<span class="sd">            iterator.</span>
<span class="sd">        events_total : ``int``</span>
<span class="sd">            total number of events.</span>
<span class="sd">        output_path : ``str``</span>
<span class="sd">            path to the output json file.</span>
<span class="sd">        meta_data_path : ``str``</span>
<span class="sd">            path to the metadata json file.</span>
<span class="sd">        buffer_file : ``str``</span>
<span class="sd">            path to the buffer json file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">continue_condition</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">meta_data_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">meta_data_file</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">output_jsonfile</span>
        <span class="k">if</span> <span class="n">meta_data_path</span> <span class="o">==</span> <span class="n">output_path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;meta_data_file and output_jsonfile cannot be same.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">resume</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># iterator</span>
            <span class="n">events_total</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">remove_file</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="n">remove_file</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get sample size as size from json file</span>
            <span class="n">buffer_condition</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;data on output file </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2"> not found or corrupted. Starting from scratch.&quot;</span>
                <span class="p">)</span>
                <span class="n">remove_file</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
                <span class="n">remove_file</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
                <span class="n">buffer_condition</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">meta_data</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;data on meta data file </span><span class="si">{</span><span class="n">meta_data_path</span><span class="si">}</span><span class="s2"> not found or corrupted. Starting from scratch.&quot;</span>
                <span class="p">)</span>
                <span class="n">remove_file</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
                <span class="n">remove_file</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
                <span class="n">buffer_condition</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">buffer_condition</span><span class="p">:</span>
                <span class="n">n_collected</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_final</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;detectable_events&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">events_total</span> <span class="o">=</span> <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;events_total&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">n_collected</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Number of collected events does not match with the number of events in the meta data file.&quot;</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resuming from </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> detectable events.&quot;</span><span class="p">)</span>
                    <span class="c1"># check if stopping criteria is met</span>
                    <span class="n">continue_condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_continue_condition_check</span><span class="p">(</span>
                        <span class="n">size</span><span class="p">,</span>
                        <span class="n">meta_data</span><span class="p">,</span>
                        <span class="n">stopping_criteria</span><span class="p">,</span>
                        <span class="n">initial_continue_condition</span><span class="o">=</span><span class="n">continue_condition</span><span class="p">,</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">continue_condition</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;Stopping criteria met. There will be no more samples collected.&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">events_total</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">buffer_file</span> <span class="o">=</span> <span class="s2">&quot;params_buffer.json&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of detectable events = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">n</span><span class="p">,</span>
            <span class="n">events_total</span><span class="p">,</span>
            <span class="n">output_path</span><span class="p">,</span>
            <span class="n">meta_data_path</span><span class="p">,</span>
            <span class="n">buffer_file</span><span class="p">,</span>
            <span class="n">continue_condition</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_continue_condition_check</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">size_to_collect</span><span class="p">,</span>
        <span class="n">param_dict</span><span class="p">,</span>
        <span class="n">stopping_criteria</span><span class="p">,</span>
        <span class="n">initial_continue_condition</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="n">continue_condition</span> <span class="o">=</span> <span class="n">initial_continue_condition</span>
        <span class="n">already_collected_size</span> <span class="o">=</span> <span class="n">param_dict</span><span class="p">[</span><span class="s2">&quot;detectable_events&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># check if stopping criteria is met</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stopping_criteria</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">total_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">param_dict</span><span class="p">[</span><span class="s2">&quot;total_rate&quot;</span><span class="p">])</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="n">stopping_criteria</span><span class="p">[</span><span class="s2">&quot;relative_diff_percentage&quot;</span><span class="p">]</span>
            <span class="n">num_a</span> <span class="o">=</span> <span class="n">stopping_criteria</span><span class="p">[</span><span class="s2">&quot;number_of_last_batches_to_check&quot;</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_rates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">num_a</span><span class="p">:</span>
                <span class="n">num_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_a</span><span class="p">))</span>
                <span class="n">percentage_diff</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">total_rates</span><span class="p">[</span><span class="n">num_a</span><span class="p">:]</span> <span class="o">-</span> <span class="n">total_rates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">total_rates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="o">*</span> <span class="mi">100</span>
                <span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;percentage difference of total rate for the last </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">num_a</span><span class="p">)</span><span class="si">}</span><span class="s2"> cumulative batches = </span><span class="si">{</span><span class="n">percentage_diff</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">percentage_diff</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">):</span>
                    <span class="n">continue_condition</span> <span class="o">&amp;=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">rf</span><span class="s2">&quot;stopping criteria of rate relative difference of </span><span class="si">{</span><span class="n">limit</span><span class="si">}</span><span class="s2">% for the last </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">num_a</span><span class="p">)</span><span class="si">}</span><span class="s2"> cumulative batches reached.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">continue_condition</span> <span class="o">&amp;=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size_to_collect</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">already_collected_size</span> <span class="o">&lt;</span> <span class="n">size_to_collect</span><span class="p">:</span>
                <span class="n">continue_condition</span> <span class="o">|=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Given size=</span><span class="si">{</span><span class="n">size_to_collect</span><span class="si">}</span><span class="s2"> reached</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">continue_condition</span> <span class="o">|=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">stopping_criteria</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">continue_condition</span> <span class="o">&amp;=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">continue_condition</span>

    <span class="k">def</span> <span class="nf">_trim_results_to_size</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function of &#39;selecting_n_unlensed_detectable_events&#39; and &#39;selecting_n_lensed_detectable_events&#39; functions. Trims the data in the output file to the specified size and updates the metadata accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : `int`</span>
<span class="sd">            number of samples to be selected.</span>
<span class="sd">        output_path : ``str``</span>
<span class="sd">            path to the output json file.</span>
<span class="sd">        meta_data_path : ``str``</span>
<span class="sd">            path to the metadata json file.</span>
<span class="sd">        param_type : ``str``</span>
<span class="sd">            type of parameters.</span>
<span class="sd">            default param_type = &quot;unlensed&quot;.</span>
<span class="sd">            other options are &quot;lensed&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        param_final : ``dict``</span>
<span class="sd">            dictionary of GW source parameters of the detectable events. Refer to :meth:`~unlensed_param` or :meth:`~lensed_param` for details.</span>
<span class="sd">        new_total_rate : ``float``</span>
<span class="sd">            total rate (yr^-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> trmming final result to size=</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="c1"># randomly select size number of samples</span>
        <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">param_final</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">len_</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># trim the final param dictionary, randomly, without repeating</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param_final</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">param_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># change meta data</span>
        <span class="n">meta_data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
        <span class="n">old_events_total</span> <span class="o">=</span> <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;events_total&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">old_detectable_events</span> <span class="o">=</span> <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;detectable_events&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># adjust the meta data</span>
        <span class="c1"># following is to keep rate the same</span>
        <span class="n">new_events_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">old_events_total</span> <span class="o">/</span> <span class="n">old_detectable_events</span><span class="p">)</span>
        <span class="n">new_total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span>
            <span class="n">size</span><span class="p">,</span> <span class="n">new_events_total</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="n">param_type</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;events_total&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_events_total</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;detectable_events&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;total_rate&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_total_rate</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of detectable events = &quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total number of events = &quot;</span><span class="p">,</span> <span class="n">new_events_total</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> event rate (yr^-1): </span><span class="si">{</span><span class="n">new_total_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># save the meta data</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># save the final param dictionary</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">param_final</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">param_final</span><span class="p">,</span> <span class="n">new_total_rate</span>

    <span class="k">def</span> <span class="nf">_append_meta_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">total_rate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function for appending meta data json file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_data_path : ``str``</span>
<span class="sd">            path to the metadata json file.</span>
<span class="sd">        n : `int`</span>
<span class="sd">            iterator.</span>
<span class="sd">        events_total : `int`</span>
<span class="sd">            total number of events.</span>
<span class="sd">        total_rate : ``float``</span>
<span class="sd">            total rate (yr^-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># save meta data</span>
        <span class="n">meta_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">events_total</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">events_total</span><span class="p">]),</span>
            <span class="n">detectable_events</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">n</span><span class="p">]),</span>
            <span class="n">total_rate</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">total_rate</span><span class="p">]),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dict_</span> <span class="o">=</span> <span class="n">append_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in appending meta data. Replacing the existing meta data file.&quot;</span><span class="p">)</span>
                <span class="c1"># remove and recreate the meta data file</span>
                <span class="n">remove_file</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
                <span class="n">dict_</span> <span class="o">=</span> <span class="n">append_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dict_</span> <span class="o">=</span> <span class="n">append_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">batch_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;detectable_events&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;detectable_events&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dict_</span><span class="p">[</span><span class="s2">&quot;detectable_events&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of detectable events (batch) = &quot;</span><span class="p">,</span> <span class="n">batch_n</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of detectable events (cumulative) = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total number of events = &quot;</span><span class="p">,</span> <span class="n">events_total</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total rate (yr^-1): </span><span class="si">{</span><span class="n">total_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dict_</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.create_new_interpolator">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.create_new_interpolator">[docs]</a>
    <span class="k">def</span> <span class="nf">create_new_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configuration dictionary for interpolator creation settings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        create_new_interpolator : ``dict``</span>
<span class="sd">            Dictionary specifying which interpolators to create. \n</span>
<span class="sd">            Each key is an interpolator name, and values are dicts with: \n</span>
<span class="sd">            - &#39;create_new&#39;: bool - Whether to create new interpolator \n</span>
<span class="sd">            - &#39;resolution&#39;: int or list - Grid resolution for interpolation \n</span>
<span class="sd">            Special key &#39;gwsnr&#39; is a bool for GWSNR interpolator creation.</span>
<span class="sd">            Default: dict(</span>
<span class="sd">                merger_rate_density = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                redshift_distribution = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                luminosity_distance = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                differential_comoving_volume = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                source_frame_masses = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                geocent_time = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                ra = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                dec = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                phase = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                psi = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                theta_jn = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                a_1 = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                a_2 = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                tilt_1 = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                tilt_2 = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                phi_12 = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                phi_jl = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                velocity_dispersion = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500, &#39;zl_resolution&#39;: 48},</span>
<span class="sd">                axis_ratio = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500, &#39;sigma_resolution&#39;: 48},</span>
<span class="sd">                lens_redshift = {&#39;create_new&#39;: False, &#39;resolution&#39;: 48, &#39;zl_resolution&#39;: 48},</span>
<span class="sd">                lens_redshift_intrinsic = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                optical_depth = {&#39;create_new&#39;: False, &#39;resolution&#39;: 48},</span>
<span class="sd">                comoving_distance = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                angular_diameter_distance = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                angular_diameter_distance_z1z2 = {&#39;create_new&#39;: False, &#39;resolution&#39;: 500},</span>
<span class="sd">                density_profile_slope = {&#39;create_new&#39;: False, &#39;resolution&#39;: 100},</span>
<span class="sd">                lens_parameters_kde_sl = {&#39;create_new&#39;: False, &#39;resolution&#39;: 5000},</span>
<span class="sd">                cross_section = {&#39;create_new&#39;: False, &#39;resolution&#39;: [25, 25, 45, 15, 15]},</span>
<span class="sd">                gwsnr = False,</span>
<span class="sd">            )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_new_interpolator</span></div>


    <span class="nd">@create_new_interpolator</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">create_new_interpolator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_new_interpolator</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.npool">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.npool">[docs]</a>
    <span class="k">def</span> <span class="nf">npool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of parallel processing cores.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        npool : ``int``</span>
<span class="sd">            Number of logical cores to use for multiprocessing. \n</span>
<span class="sd">            default: 4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_npool</span></div>


    <span class="nd">@npool</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">npool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_npool</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.z_min">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.z_min">[docs]</a>
    <span class="k">def</span> <span class="nf">z_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Minimum redshift of the source population.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        z_min : ``float``</span>
<span class="sd">            Minimum source redshift for sampling. \n</span>
<span class="sd">            default: 0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_min</span></div>


    <span class="nd">@z_min</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">z_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_min</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.z_max">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.z_max">[docs]</a>
    <span class="k">def</span> <span class="nf">z_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maximum redshift of the source population.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        z_max : ``float``</span>
<span class="sd">            Maximum source redshift for sampling. \n</span>
<span class="sd">            default: 10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_z_max</span></div>


    <span class="nd">@z_max</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">z_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_z_max</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.event_type">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.event_type">[docs]</a>
    <span class="k">def</span> <span class="nf">event_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type of compact binary coalescence event.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        event_type : ``str``</span>
<span class="sd">            Type of CBC event. \n</span>
<span class="sd">            Options: \n</span>
<span class="sd">            - &#39;BBH&#39;: Binary Black Hole \n</span>
<span class="sd">            - &#39;BNS&#39;: Binary Neutron Star \n</span>
<span class="sd">            - &#39;NSBH&#39;: Neutron Star-Black Hole \n</span>
<span class="sd">            default: &#39;BBH&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_event_type</span></div>


    <span class="nd">@event_type</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">event_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_event_type</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.lens_type">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.lens_type">[docs]</a>
    <span class="k">def</span> <span class="nf">lens_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type of lens galaxy model.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lens_type : ``str``</span>
<span class="sd">            Type of lens model. \n</span>
<span class="sd">            Options: \n</span>
<span class="sd">            - &#39;epl_shear_galaxy&#39;: Elliptical Power Law with external shear \n</span>
<span class="sd">            - &#39;sie_galaxy&#39;: Singular Isothermal Ellipsoid \n</span>
<span class="sd">            - &#39;sis_galaxy&#39;: Singular Isothermal Sphere \n</span>
<span class="sd">            default: &#39;epl_shear_galaxy&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lens_type</span></div>


    <span class="nd">@lens_type</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">lens_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lens_type</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.cosmo">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.cosmo">[docs]</a>
    <span class="k">def</span> <span class="nf">cosmo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Astropy cosmology object for distance calculations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cosmo : ``astropy.cosmology``</span>
<span class="sd">            Cosmology used for luminosity distance and comoving volume calculations. \n</span>
<span class="sd">            default: LambdaCDM(H0=70, Om0=0.3, Ode0=0.7, Tcmb0=0.0, Neff=3.04, m_nu=None, Ob0=0.0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cosmo</span></div>


    <span class="nd">@cosmo</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cosmo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cosmo</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.json_file_names">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.json_file_names">[docs]</a>
    <span class="k">def</span> <span class="nf">json_file_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary of JSON file names for parameter storage.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        json_file_names : ``dict``</span>
<span class="sd">            Dictionary with keys: \n</span>
<span class="sd">            - &#39;ler_params&#39;: LeR initialization parameters \n</span>
<span class="sd">            - &#39;unlensed_param&#39;: Unlensed event parameters \n</span>
<span class="sd">            - &#39;unlensed_param_detectable&#39;: Detectable unlensed events \n</span>
<span class="sd">            - &#39;lensed_param&#39;: Lensed event parameters \n</span>
<span class="sd">            - &#39;lensed_param_detectable&#39;: Detectable lensed events \n</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_json_file_names</span></div>


    <span class="nd">@json_file_names</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">json_file_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_json_file_names</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.interpolator_directory">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.interpolator_directory">[docs]</a>
    <span class="k">def</span> <span class="nf">interpolator_directory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Directory path for interpolator JSON files.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        interpolator_directory : ``str``</span>
<span class="sd">            Path to directory containing interpolator data files. \n</span>
<span class="sd">            default: &#39;./interpolator_json&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interpolator_directory</span></div>


    <span class="nd">@interpolator_directory</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">interpolator_directory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_interpolator_directory</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.ler_directory">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.ler_directory">[docs]</a>
    <span class="k">def</span> <span class="nf">ler_directory</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Directory path for LeR output files.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ler_directory : ``str``</span>
<span class="sd">            Path to directory for storing output parameter files. \n</span>
<span class="sd">            default: &#39;./ler_data&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ler_directory</span></div>


    <span class="nd">@ler_directory</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ler_directory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ler_directory</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.pdet_finder">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.pdet_finder">[docs]</a>
    <span class="k">def</span> <span class="nf">pdet_finder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detection probability finder function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pdet_finder : ``callable``</span>
<span class="sd">            Function that calculates detection probability for GW events. \n</span>
<span class="sd">            The function signature should be: \n</span>
<span class="sd">            ``pdet_finder(gw_param_dict) -&gt; dict`` with key &#39;pdet_net&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdet_finder</span></div>


    <span class="nd">@pdet_finder</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">pdet_finder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pdet_finder</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.ler_args">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.LeR.ler_args">[docs]</a>
    <span class="k">def</span> <span class="nf">ler_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dictionary of all LeR initialization arguments.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ler_args : ``dict``</span>
<span class="sd">            Dictionary containing all parameters used to initialize LeR and \n</span>
<span class="sd">            its parent classes, useful for reproducibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ler_args</span></div>


    <span class="nd">@ler_args</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ler_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ler_args</span> <span class="o">=</span> <span class="n">value</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Phurailatpam Hemantakumar.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>