

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ler.rates.ler &mdash; ler 0.3.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=a5c4661c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=776609e1" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=4621528c"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../../_static/tabs.js?v=3030b3cb"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            ler
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Installation2.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Summary.html">Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../code_overview.html">Code overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GW_events.html">Gravitational wave event rates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../GW_equations.html">Gravitational wave events sampling (Analytical formulation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Lensed_events.html">Lensed event rates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Lensed_equations.html">Lensed event sampling (Analytical formulation)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/rates/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.rates</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/gw_source_population/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.gw_source_population</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/lens_galaxy_population/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.lens_galaxy_population</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/image_properties/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.image_properties</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../autoapi/ler/utils/index.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ler.utils</span></code></a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rates/LeR%20complete%20examples.html">LeR complete examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rates/GWRATES%20complete%20exmaples.html">GWRATES complete exmaples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rates/grb%20detection%20rate.html">Calculation of detectable Gamma ray burst (GRB) event rate associated with Binary Neutron Star (BNS) mergers.</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rates/ler%20bns%20example.html">LeR complete examples of BNS events (O4 design sensitivity)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/rates/rates_with_3G_detectors.html">Event Rates with 3G detectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/source%20population/merger%20rate%20density%20evolution%20with%20redshift.html">Merger rate density evolution with redshift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/source%20population/merger%20rate%20density%20model%20comparision.html">Merger rate density model comparision</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/source%20population/merger%20rate%20density%20model%20comparision.html#Primordial-BBH-model,-Ng-et-al.-2022">Primordial BBH model, Ng et al. 2022</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/source%20population/sample%20compact%20binary%20parameters.html">Sampling parameters for a compact binary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/source%20population/statistical%20study%20of%20changing%20mass%20model%20params.html">Statistical study of changing Mass model paramter(s)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/source%20population/statistical%20study%20of%20cosmological%20friction.html">Statistical study of cosmological friction and its effect on the redshift vs inferred chirp-mass relation of gravitational waves</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/lens_parameters/sample%20lens%20parameters.html">Lens parameter distributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/optical_depth/validation_SIE.html">Optical depth SIE model validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/optical_depth/validation_SIS.html">Validation of SIS model (Numerical vs Analytical)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/image_properties/dt_vs_dmu.html">Study of Time delays and magnification of lensed gravitational waves.</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">ler</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ler.rates.ler</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ler.rates.ler</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the main class for calculating the rates of detectable gravitational waves events. The class inherits the :class:`~ler.lens_galaxy_population.LensGalaxyParameterDistribution` class for source parameters and lens parameters sampling. It also finds the image properties. :class:`~ler.lens_galaxy_population.LensGalaxyParameterDistribution` inherits the :class:`~ler.gw_source_population.CBCSourceParameterDistribution`, :class:`~ler.image_properties.ImageProperties` and uses `gwsnr` package for SNR calculation. </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;numexpr.utils&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">astropy.cosmology</span> <span class="kn">import</span> <span class="n">LambdaCDM</span>
<span class="kn">from</span> <span class="nn">..lens_galaxy_population</span> <span class="kn">import</span> <span class="n">LensGalaxyParameterDistribution</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">load_json</span><span class="p">,</span> <span class="n">append_json</span><span class="p">,</span> <span class="n">get_param_from_json</span><span class="p">,</span> <span class="n">batch_handler</span>


<div class="viewcode-block" id="LeR">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR">[docs]</a>
<span class="k">class</span> <span class="nc">LeR</span><span class="p">(</span><span class="n">LensGalaxyParameterDistribution</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to sample of lensed and unlensed events and calculate it&#39;s rates. Please note that parameters of the simulated events are stored in json file but not as an attribute of the class. This saves RAM memory. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    npool : `int`</span>
<span class="sd">        number of cores to use.</span>
<span class="sd">        default npool = 4.</span>
<span class="sd">    z_min : `float`</span>
<span class="sd">        minimum redshift.</span>
<span class="sd">        default z_min = 0.</span>
<span class="sd">        for popI_II, popIII, primordial, BNS z_min = 0., 5., 5., 0. respectively.</span>
<span class="sd">    z_max : `float`</span>
<span class="sd">        maximum redshift.</span>
<span class="sd">        default z_max = 10.</span>
<span class="sd">        for popI_II, popIII, primordial, BNS z_max = 10., 40., 40., 5. respectively.</span>
<span class="sd">    event_type : `str`</span>
<span class="sd">        type of event to generate.</span>
<span class="sd">        default event_type = &#39;BBH&#39;. Other options are &#39;BNS&#39;, &#39;NSBH&#39;.</span>
<span class="sd">    size : `int`</span>
<span class="sd">        number of samples for sampling.</span>
<span class="sd">        default size = 100000. To get stable rates, size should be large (&gt;=1e6).</span>
<span class="sd">    batch_size : `int`</span>
<span class="sd">        batch size for SNR calculation.</span>
<span class="sd">        default batch_size = 50000.</span>
<span class="sd">        reduce the batch size if you are getting memory error.</span>
<span class="sd">        recommended batch_size = 200000, if size = 1000000.</span>
<span class="sd">    cosmology : `astropy.cosmology`</span>
<span class="sd">        cosmology to use for the calculation.</span>
<span class="sd">        default cosmology = LambdaCDM(H0=70, Om0=0.3, Ode0=0.7).</span>
<span class="sd">    snr_finder : `str` or `function`</span>
<span class="sd">        default snr_finder = &#39;gwsnr&#39;.</span>
<span class="sd">        if None, the SNR will be calculated using the gwsnr package.</span>
<span class="sd">        if custom snr finder function is provided, the SNR will be calculated using a custom function. The custom function should follow the following signature:</span>
<span class="sd">        def snr_finder(gw_param_dict):</span>
<span class="sd">            ...</span>
<span class="sd">            return optimal_snr_dict</span>
<span class="sd">        where optimal_snr_dict.keys = [&#39;optimal_snr_net&#39;]. Refer to `gwsnr` package&#39;s GWSNR.snr attribute for more details.</span>
<span class="sd">    pdet_finder : `function`</span>
<span class="sd">        default pdet_finder = None.</span>
<span class="sd">        The rate calculation uses either the pdet_finder or the snr_finder to calculate the detectable events. The custom pdet finder function should follow the following signature:</span>
<span class="sd">        def pdet_finder(gw_param_dict):</span>
<span class="sd">            ...</span>
<span class="sd">            return pdet_net_dict</span>
<span class="sd">        where pdet_net_dict.keys = [&#39;pdet_net&#39;]. For example uses, refer to [GRB pdet example](https://ler.readthedocs.io/en/latest/examples/rates/grb%20detection%20rate.html).</span>
<span class="sd">    list_of_detectors : `list`</span>
<span class="sd">        list of detectors.</span>
<span class="sd">        default list_of_detectors = [&#39;H1&#39;, &#39;L1&#39;, &#39;V1&#39;]. This is used for lensed SNR calculation wrt to the detectors. Provide &#39;None&#39; if you only need net SNR/Pdet. Refer to ImageProperties.get_lensed_snrs for more details.</span>
<span class="sd">    json_file_names: `dict`</span>
<span class="sd">        names of the json files to strore the necessary parameters.</span>
<span class="sd">        default json_file_names = {&#39;ler_params&#39;: &#39;LeR_params.json&#39;, &#39;unlensed_param&#39;: &#39;unlensed_param.json&#39;, &#39;unlensed_param_detectable&#39;: &#39;unlensed_param_detectable.json&#39;}.</span>
<span class="sd">    interpolator_directory : `str`</span>
<span class="sd">        directory to store the interpolators.</span>
<span class="sd">        default interpolator_directory = &#39;./interpolator_pickle&#39;. This is used for storing the various interpolators related to `ler` and `gwsnr` package.</span>
<span class="sd">    create_new_interpolator : `bool` or `dict`</span>
<span class="sd">        default create_new_interpolator = False.</span>
<span class="sd">        if True, the all interpolators (including `gwsnr`&#39;s)will be created again.</span>
<span class="sd">        if False, the interpolators will be loaded from the interpolator_directory if they exist.</span>
<span class="sd">        if dict, you can specify which interpolators to create new. Complete example (change any of them to True), create_new_interpolator = create_new_interpolator = dict(</span>
<span class="sd">            redshift_distribution=dict(create_new=False, resolution=1000),</span>
<span class="sd">            z_to_luminosity_distance=dict(create_new=False, resolution=1000),</span>
<span class="sd">            velocity_dispersion=dict(create_new=False, resolution=1000),</span>
<span class="sd">            axis_ratio=dict(create_new=False, resolution=1000),</span>
<span class="sd">            optical_depth=dict(create_new=False, resolution=200),</span>
<span class="sd">            z_to_Dc=dict(create_new=False, resolution=1000),</span>
<span class="sd">            Dc_to_z=dict(create_new=False, resolution=1000),</span>
<span class="sd">            angular_diameter_distance=dict(create_new=False, resolution=1000),</span>
<span class="sd">            differential_comoving_volume=dict(create_new=False, resolution=1000),</span>
<span class="sd">            Dl_to_z=dict(create_new=False, resolution=1000),</span>
<span class="sd">            gwsnr=False,</span>
<span class="sd">        )</span>
<span class="sd">    ler_directory : `str`</span>
<span class="sd">        directory to store the parameters.</span>
<span class="sd">        default ler_directory = &#39;./ler_data&#39;. This is used for storing the parameters of the simulated events.</span>
<span class="sd">    verbose : `bool`</span>
<span class="sd">        default verbose = True.</span>
<span class="sd">        if True, the function will print all chosen parameters.</span>
<span class="sd">        Choose False to prevent anything from printing.</span>
<span class="sd">    kwargs : `keyword arguments`</span>
<span class="sd">        Note : kwargs takes input for initializing the :class:`~ler.lens_galaxy_population.LensGalaxyParameterDistribution`, :class:`~ler.gw_source_population.CBCSourceParameterDistribution`, :class:`~ler.gw_source_population.CBCSourceRedshiftDistribution` and :class:`~ler.image_properties.ImageProperties` classes. If snr_finder=&#39;gwsnr&#39;, then kwargs also takes input for initializing the :class:`~gwsnr.GWSNR` class. Please refer to the respective classes for more details.</span>

<span class="sd">    Examples</span>
<span class="sd">    ----------</span>
<span class="sd">    &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">    &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">    &gt;&gt;&gt; unlensed_params = ler.unlensed_cbc_statistics();</span>
<span class="sd">    &gt;&gt;&gt; ler.unlensed_rate();</span>
<span class="sd">    &gt;&gt;&gt; lensed_params = ler.lensed_cbc_statistics();</span>
<span class="sd">    &gt;&gt;&gt; ler.lensed_rate();</span>
<span class="sd">    &gt;&gt;&gt; ler.rate_ratio();</span>
<span class="sd">        </span>
<span class="sd">    Instance Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    LeR class has the following attributes: \n</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    | Atrributes                          | Type                             |</span>
<span class="sd">    +=====================================+==================================+</span>
<span class="sd">    |:attr:`~npool`                       | `int`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~z_min`                       | `float`                          |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~z_max`                       | `float`                          |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~event_type`                  | `str`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~cosmo`                       | `astropy.cosmology`              |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~size`                        | `int`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~batch_size`                  | `int`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~json_file_names`             | `dict`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~interpolator_directory`      | `str`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~ler_directory`               | `str`                            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~gwsnr`                       | `bool`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~gw_param_sampler_dict`       | `dict`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~snr_calculator_dict`         | `dict`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~list_of_detectors`           | `list`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~unlensed_param`              | `dict`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~unlensed_param_detectable`   | `dict`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~lensed_param`                | `dict`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:attr:`~lensed_param_detectable`     | `dict`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>

<span class="sd">    Instance Methods</span>
<span class="sd">    ----------</span>
<span class="sd">    LeR class has the following methods:\n</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    | Methods                             | Description                      |</span>
<span class="sd">    +=====================================+==================================+</span>
<span class="sd">    |:meth:`~class_initialization`        | Function to initialize the       |</span>
<span class="sd">    |                                     | parent classes                   |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~gwsnr_initialization`         | Function to initialize the       |</span>
<span class="sd">    |                                     | gwsnr class                      |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~snr`                         | Function to get the snr with the |</span>
<span class="sd">    |                                     | given parameters.                |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~snr_bilby`                   | Function to get the snr with the |</span>
<span class="sd">    |                                     | given parameters using inner-    |</span>
<span class="sd">    |                                     | product method.                  |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~pdet`                        | Function to get the pdet with    |</span>
<span class="sd">    |                                     | the given parameters.            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~store_ler_params`            | Function to store the all the    |</span>
<span class="sd">    |                                     | necessary parameters.            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~unlensed_cbc_statistics`     | Function to generate unlensed    |</span>
<span class="sd">    |                                     | GW source parameters in batches. |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~unlensed_sampling_routine`   | Function to generate unlensed    |</span>
<span class="sd">    |                                     | GW source parameters. It stores  |</span>
<span class="sd">    |                                     | the parameters of the generated  |</span>
<span class="sd">    |                                     | events in a json file.           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~unlensed_rate`               | Function to calculate the        |</span>
<span class="sd">    |                                     | unlensed rate. It also stores    |</span>
<span class="sd">    |                                     | the parameters of the detectable |</span>
<span class="sd">    |                                     | unlesed events in a json file.   |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~lensed_cbc_statistics`       | Function to generate lensed      |</span>
<span class="sd">    |                                     | GW source parameters.            |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~lensed_sampling_routine`     | Function to generate lensed      |</span>
<span class="sd">    |                                     | GW source parameters. It stores  |</span>
<span class="sd">    |                                     | the parameters of the generated  |</span>
<span class="sd">    |                                     | events in a json file.           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~lensed_rate`                 | Function to calculate the        |</span>
<span class="sd">    |                                     | lensed rate. It also stores the  |</span>
<span class="sd">    |                                     | parameters of the detectable     |</span>
<span class="sd">    |                                     | lensed events in a json file.    |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~rate_ratio`                  | Function to calculate the rate   |</span>
<span class="sd">    |                                     | ratio between lensed and         |</span>
<span class="sd">    |                                     | unlensed events.                 |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~rate_comparison_with_rate_calculation`                          |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |                                     | Function to calculate rates for  |</span>
<span class="sd">    |                                     | unleesed and lensed events and   |</span>
<span class="sd">    |                                     | compare it with the rate. It also|</span>
<span class="sd">    |                                     | stores the parameters of the     |</span>
<span class="sd">    |                                     | detectable events in a json file.|</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~selecting_n_unlensed_detectable_events`                         |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |                                     | Function to select n unlensed    |</span>
<span class="sd">    |                                     | detectable events. It stores the |</span>
<span class="sd">    |                                     | parameters of the detectable     |</span>
<span class="sd">    |                                     | unlesed events in a json file.   |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |:meth:`~selecting_n_lensed_detectable_events`                           |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>
<span class="sd">    |                                     | Function to select n lensed      |</span>
<span class="sd">    |                                     | detectable events. It stores the |</span>
<span class="sd">    |                                     | parameters of the detectable     |</span>
<span class="sd">    |                                     | lensed events in a json file.    |</span>
<span class="sd">    +-------------------------------------+----------------------------------+</span>

<span class="sd">    Note: `LeR` class also inherits all the instances from the :class:`~ler.lens_galaxy_population.LensGalaxyParameterDistribution` class. Please refer to the :class:`~ler.lens_galaxy_population.LensGalaxyParameterDistribution` class for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Attributes</span>

<div class="viewcode-block" id="LeR.npool">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.npool">[docs]</a>
    <span class="n">npool</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``int`` \n</span>
<span class="sd">    Number of logical cores to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.z_min">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.z_min">[docs]</a>
    <span class="n">z_min</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``float`` \n</span>
<span class="sd">    Minimum redshift of the source population</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.z_max">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.z_max">[docs]</a>
    <span class="n">z_max</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``float`` \n</span>
<span class="sd">    Maximum redshift of the source population</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.event_type">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.event_type">[docs]</a>
    <span class="n">event_type</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``str`` \n</span>
<span class="sd">    Type of event to generate. \n</span>
<span class="sd">    e.g. &#39;BBH&#39;, &#39;BNS&#39;, &#39;NSBH&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.cosmo">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.cosmo">[docs]</a>
    <span class="n">cosmo</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``astropy.cosmology`` \n</span>
<span class="sd">    Cosmology to use for the calculation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.size">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.size">[docs]</a>
    <span class="n">size</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``int`` \n</span>
<span class="sd">    Number of samples for sampling.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.batch_size">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.batch_size">[docs]</a>
    <span class="n">batch_size</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``int`` \n</span>
<span class="sd">    Batch size for sampling.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.json_file_names">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.json_file_names">[docs]</a>
    <span class="n">json_file_names</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    Names of the json files to store the necessary parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.interpolator_directory">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.interpolator_directory">[docs]</a>
    <span class="n">interpolator_directory</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``str`` \n</span>
<span class="sd">    Directory to store the interpolators.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.ler_directory">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.ler_directory">[docs]</a>
    <span class="n">ler_directory</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``str`` \n</span>
<span class="sd">    Directory to store the parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.gwsnr">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.gwsnr">[docs]</a>
    <span class="n">gwsnr</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``bool`` \n</span>
<span class="sd">    If True, the SNR will be calculated using the gwsnr package.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.gw_param_sampler_dict">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.gw_param_sampler_dict">[docs]</a>
    <span class="n">gw_param_sampler_dict</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    Dictionary of parameters to initialize the ``CBCSourceParameterDistribution`` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.snr_calculator_dict">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.snr_calculator_dict">[docs]</a>
    <span class="n">snr_calculator_dict</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    Dictionary of parameters to initialize the ``GWSNR`` class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.list_of_detectors">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.list_of_detectors">[docs]</a>
    <span class="n">list_of_detectors</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``list`` \n</span>
<span class="sd">    List of detectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.unlensed_param">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.unlensed_param">[docs]</a>
    <span class="n">unlensed_param</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    Dictionary of unlensed GW source parameters. The included parameters and their units are as follows (for default settings):\n</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | Parameter          | Units        | Description                          |</span>
<span class="sd">    +====================+==============+======================================+</span>
<span class="sd">    | zs                 |              | redshift of the source               |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | geocent_time       | s            | GPS time of coalescence              |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | ra                 | rad          | right ascension                      |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | dec                | rad          | declination                          |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | phase              | rad          | phase of GW at reference frequency   |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | psi                | rad          | polarization angle                   |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | theta_jn           | rad          | inclination angle                    |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | luminosity_distance| Mpc          | luminosity distance                  |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | mass_1_source      | Msun         | mass_1 of the compact binary         |</span>
<span class="sd">    |                    |              | (source frame)                       |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | mass_2_source      | Msun         | mass_2 of the compact binary         |</span>
<span class="sd">    |                    |              | (source frame)                       |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | mass_1             | Msun         | mass_1 of the compact binary         |</span>
<span class="sd">    |                    |              | (detector frame)                     |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | mass_2             | Msun         | mass_2 of the compact binary         |</span>
<span class="sd">    |                    |              | (detector frame)                     |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | L1                 |              | optimal snr of L1                    |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | H1                 |              | optimal snr of H1                    |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | V1                 |              | optimal snr of V1                    |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    | optimal_snr_net    |              | optimal snr of the network           |</span>
<span class="sd">    +--------------------+--------------+--------------------------------------+</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.unlensed_param_detectable">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.unlensed_param_detectable">[docs]</a>
    <span class="n">unlensed_param_detectable</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    Dictionary of detectable unlensed GW source parameters. It includes the same parameters as the :attr:`~unlensed_param` attribute.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.lensed_param">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.lensed_param">[docs]</a>
    <span class="n">lensed_param</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    Dictionary of lens parameters, images parameters and lensed GW source parameters. The included parameters and their units are as follows (for default settings):\n</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | Parameter                    | Units     | Description                   |</span>
<span class="sd">    +==============================+===========+===============================+</span>
<span class="sd">    | zl                           |           | redshift of the lens          |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | zs                           |           | redshift of the source        |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | sigma                        |km s^-1    | velocity dispersion           |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | q                            |           | axis ratio                    |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | theta_E                      | arcsec    | Einstein radius               |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | phi                          | rad       | axis rotation angle           |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | e1                           |           | ellipticity component 1       |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | e2                           |           | ellipticity component 2       |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | gamma1                       |           | shear component 1             |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | gamma2                       |           | shear component 2             |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | gamma                        |           | shear                         |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | ra                           | rad       | right ascension               |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | dec                          | rad       | declination                   |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | phase                        | rad       | phase of GW at reference freq |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | psi                          | rad       | polarization angle            |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | theta_jn                     | rad       | inclination angle             |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | mass_1_source                | Msun      | mass_1 of the compact binary  |</span>
<span class="sd">    |                              |           | (source frame)                |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | mass_2_source                | Msun      | mass_2 of the compact binary  |</span>
<span class="sd">    |                              |           | (source frame)                |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | mass_1                       | Msun      | mass_1 of the compact binary  |</span>
<span class="sd">    |                              |           | (detector frame)              |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | mass_2                       | Msun      | mass_2 of the compact binary  |</span>
<span class="sd">    |                              |           | (detector frame)              |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | x0_image_positions           |           | x0 image positions            |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | x1_image_positions           |           | x1 image positions            |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | magnifications               |           | magnifications                |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | time_delays                  |           | time delays                   |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | image_type                   |           | image type                    |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | n_images                     |           | number of images              |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | effective_luminosity_distance| Mpc       | effective luminosity distance |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | effective_geocent_time       | s         | effective GPS time of coalesc |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | L1                           |           | optimal snr of L1             |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | H1                           |           | optimal snr of H1             |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | V1                           |           | optimal snr of V1             |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    | optimal_snr_net              |           | optimal snr of the network    |</span>
<span class="sd">    +------------------------------+-----------+-------------------------------+</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LeR.lensed_param_detectable">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.lensed_param_detectable">[docs]</a>
    <span class="n">lensed_param_detectable</span> <span class="o">=</span> <span class="kc">None</span></div>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;``dict`` \n</span>
<span class="sd">    Dictionary of detectable lensed GW source parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">npool</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
        <span class="n">z_min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">z_max</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
        <span class="n">event_type</span><span class="o">=</span><span class="s2">&quot;BBH&quot;</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span>
        <span class="n">cosmology</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">snr_finder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">pdet_finder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">list_of_detectors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">json_file_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">interpolator_directory</span><span class="o">=</span><span class="s2">&quot;./interpolator_pickle&quot;</span><span class="p">,</span>
        <span class="n">create_new_interpolator</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ler_directory</span><span class="o">=</span><span class="s2">&quot;./ler_data&quot;</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Initializing LeR class...</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">npool</span> <span class="o">=</span> <span class="n">npool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_min</span> <span class="o">=</span> <span class="n">z_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_max</span> <span class="o">=</span> <span class="n">z_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_type</span> <span class="o">=</span> <span class="n">event_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cosmo</span> <span class="o">=</span> <span class="n">cosmology</span> <span class="k">if</span> <span class="n">cosmology</span> <span class="k">else</span> <span class="n">LambdaCDM</span><span class="p">(</span><span class="n">H0</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">Om0</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">Ode0</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">ler_params</span><span class="o">=</span><span class="s2">&quot;ler_params.json&quot;</span><span class="p">,</span> <span class="n">unlensed_param</span><span class="o">=</span><span class="s2">&quot;unlensed_param.json&quot;</span><span class="p">,</span> <span class="n">unlensed_param_detectable</span><span class="o">=</span><span class="s2">&quot;unlensed_param_detectable.json&quot;</span><span class="p">,</span> <span class="n">lensed_param</span><span class="o">=</span><span class="s2">&quot;lensed_param.json&quot;</span><span class="p">,</span> <span class="n">lensed_param_detectable</span><span class="o">=</span><span class="s2">&quot;lensed_param_detectable.json&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">json_file_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">json_file_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpolator_directory</span> <span class="o">=</span> <span class="n">interpolator_directory</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_new_interpolator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">=</span> <span class="n">ler_directory</span>
        <span class="c1"># create directory if not exists</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ler_directory</span><span class="p">):</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">ler_directory</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">initialization</span><span class="p">():</span>
            <span class="c1"># initialization of parent class</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">class_initialization</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># initialization self.snr and self.pdet from GWSNR class</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">snr_finder</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pdet_finder</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gwsnr_initialization</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gwsnr</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdet</span> <span class="o">=</span> <span class="n">pdet_finder</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">snr</span> <span class="o">=</span> <span class="n">snr_finder</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pdet</span> <span class="o">=</span> <span class="n">pdet_finder</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">gwsnr</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">list_of_detectors</span> <span class="o">=</span> <span class="n">list_of_detectors</span>
            
            <span class="c1"># store all the ler input parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">store_ler_params</span><span class="p">(</span><span class="n">output_jsonfile</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>

        <span class="c1"># if not verbose, prevent anything from printing</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">initialization</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">print_all_params_ler</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">initialization</span><span class="p">()</span>
            
<div class="viewcode-block" id="LeR.print_all_params_ler">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.print_all_params_ler">[docs]</a>
    <span class="k">def</span> <span class="nf">print_all_params_ler</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to print all the parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print all relevant functions and sampler priors</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> # LeR set up params:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;npool = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">npool</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z_min = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;z_max = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;event_type = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">event_type</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;size = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;batch_size = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;cosmology = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cosmo</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;snr_finder = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdet</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;pdet_finder = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pdet</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;json_file_names = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="si">}</span><span class="s1">,&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;interpolator_directory = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolator_directory</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ler_directory = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> # LeR also takes CBCSourceParameterDistribution class params as kwargs, as follows:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;source_priors = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s1">&#39;source_priors&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;source_priors_params = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s1">&#39;source_priors_params&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spin_zero = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s1">&#39;spin_zero&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;spin_precession = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s1">&#39;spin_precession&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;create_new_interpolator = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s1">&#39;create_new_interpolator&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> # LeR also takes LensGalaxyParameterDistribution class params as kwargs, as follows:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lens_type = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s1">&#39;lens_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lens_functions = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s1">&#39;lens_functions&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lens_param_samplers = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s1">&#39;lens_param_samplers&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lens_param_samplers_params = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s1">&#39;lens_param_samplers_params&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> # LeR also takes ImageProperties class params as kwargs, as follows:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_min_images = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_min_images</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;n_max_images = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_max_images</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;geocent_time_min = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">geocent_time_min</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;geocent_time_max = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">geocent_time_max</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lens_model_list = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_model_list</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gwsnr</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> # LeR also takes gwsnr.GWSNR params as kwargs, as follows:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mtot_min = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;mtot_min&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mtot_max = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;mtot_max&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ratio_min = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;ratio_min&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ratio_max = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;ratio_max&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mtot_resolution = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;mtot_resolution&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ratio_resolution = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;ratio_resolution&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;sampling_frequency = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;sampling_frequency&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;waveform_approximant = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;waveform_approximant&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;minimum_frequency = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;minimum_frequency&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;snr_type = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;snr_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;psds = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;psds&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ifos = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;ifos&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;interpolator_dir = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;interpolator_dir&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;gwsnr_verbose = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;gwsnr_verbose&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;multiprocessing_verbose = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;multiprocessing_verbose&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mtot_cut = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s1">&#39;mtot_cut&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">,&quot;</span><span class="p">)</span>
        <span class="c1"># del self.gwsnr</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> For reference, the chosen source parameters are listed below:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;merger_rate_density = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;merger_rate_density&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;merger_rate_density_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;merger_rate_density&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;source_frame_masses = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;source_frame_masses&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;source_frame_masses_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;source_frame_masses&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;geocent_time = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;geocent_time&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;geocent_time_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;geocent_time&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ra = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;ra&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ra_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;ra&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;dec = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;dec&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dec_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;dec&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;phase = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;phase&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;phase_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;phase&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;psi = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;psi&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;psi_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;psi&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;theta_jn = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;theta_jn&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;theta_jn_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;theta_jn&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_zero</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;a_1 = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;a_1&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a_1_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;a_1&quot;</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;a_2 = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;a_2&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a_2_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;a_2&quot;</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_precession</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tilt_1 = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;tilt_1&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tilt_1_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;tilt_1&quot;</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tilt_2 = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;tilt_2&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;tilt_2_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;tilt_2&quot;</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;phi_12 = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;phi_12&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;phi_12_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;phi_12&quot;</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;phi_jl = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="p">[</span><span class="s1">&#39;phi_jl&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;phi_jl_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;phi_jl&quot;</span><span class="p">])</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> For reference, the chosen lens related parameters and functions are listed below:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lens_redshift = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers</span><span class="p">[</span><span class="s1">&#39;lens_redshift&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;lens_redshift_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;lens_redshift&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;velocity_dispersion = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers</span><span class="p">[</span><span class="s1">&#39;velocity_dispersion&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;velocity_dispersion_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;velocity_dispersion&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis_ratio = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers</span><span class="p">[</span><span class="s1">&#39;axis_ratio&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;axis_ratio_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;axis_ratio&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;axis_rotation_angle = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers</span><span class="p">[</span><span class="s1">&#39;axis_rotation_angle&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;axis_rotation_angle_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;axis_rotation_angle&quot;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shear = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers</span><span class="p">[</span><span class="s1">&#39;external_shear&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;shear_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers_params</span><span class="p">[</span><span class="s1">&#39;external_shear&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;density_profile_slope = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers</span><span class="p">[</span><span class="s1">&#39;density_profile_slope&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;density_profile_slope_params = &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers_params</span><span class="p">[</span><span class="s2">&quot;density_profile_slope&quot;</span><span class="p">])</span>
        <span class="c1"># lens functions</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lens functions:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;strong_lensing_condition = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_functions</span><span class="p">[</span><span class="s1">&#39;strong_lensing_condition&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;optical_depth = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_functions</span><span class="p">[</span><span class="s1">&#39;optical_depth&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;optical_depth_params = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_functions_params</span><span class="p">[</span><span class="s1">&#39;optical_depth&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;param_sampler_type = &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_functions</span><span class="p">[</span><span class="s1">&#39;param_sampler_type&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
<div class="viewcode-block" id="LeR.snr">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.snr">[docs]</a>
    <span class="k">def</span> <span class="nf">snr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to get the snr with the given parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gw_param_dict : `dict`</span>
<span class="sd">            dictionary of GW source parameters.</span>
<span class="sd">            mass_1 : `numpy.ndarray` or `float`</span>
<span class="sd">                mass_1 of the compact binary (detector frame) (Msun).</span>
<span class="sd">            mass_2 : `numpy.ndarray` or `float`</span>
<span class="sd">                mass_2 of the compact binary (detector frame) (Msun).</span>
<span class="sd">            luminosity_distance : `numpy.ndarray` or `float`</span>
<span class="sd">                luminosity distance of the source (Mpc).</span>
<span class="sd">            theta_jn : `numpy.ndarray` or `float`</span>
<span class="sd">                inclination angle of the source (rad).</span>
<span class="sd">            psi : `numpy.ndarray` or `float`</span>
<span class="sd">                polarization angle of the source (rad).</span>
<span class="sd">            phase : `numpy.ndarray` or `float`</span>
<span class="sd">                phase of GW at reference frequency  (rad).</span>
<span class="sd">            geocent_time : `numpy.ndarray` or `float`</span>
<span class="sd">                GPS time of coalescence (s).</span>
<span class="sd">            ra : `numpy.ndarray` or `float`</span>
<span class="sd">                right ascension of the source (rad).</span>
<span class="sd">            dec : `numpy.ndarray` or `float`</span>
<span class="sd">                declination of the source (rad).</span>
<span class="sd">            a_1 : `numpy.ndarray` or `float`</span>
<span class="sd">                dimensionless spin magnitude of the more massive object.</span>
<span class="sd">            a_2 : `numpy.ndarray` or `float`</span>
<span class="sd">                dimensionless spin magnitude of the less massive object.</span>
<span class="sd">            tilt_1 : `numpy.ndarray` or `float`</span>
<span class="sd">                tilt angle of the more massive object spin.</span>
<span class="sd">            tilt_2 : `numpy.ndarray` or `float`</span>
<span class="sd">                tilt angle of the less massive object spin.</span>
<span class="sd">            phi_12 : `numpy.ndarray` or `float`</span>
<span class="sd">                azimuthal angle between the two spin vectors.</span>
<span class="sd">            phi_jl : `numpy.ndarray` or `float`</span>
<span class="sd">                azimuthal angle between total angular momentum and the orbital angular momentum.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        optimal_snr_list : `list`</span>
<span class="sd">            e.g. [optimal_snr_net, &#39;L1&#39;, &#39;H1&#39;, &#39;V1&#39;]</span>
<span class="sd">            optimal_snr_net : `numpy.ndarray` or `float`</span>
<span class="sd">                optimal snr of the network.</span>
<span class="sd">            &#39;H1&#39; : `numpy.ndarray` or `float`</span>
<span class="sd">                optimal snr of H1.</span>
<span class="sd">            &#39;L1&#39; : `numpy.ndarray` or `float`</span>
<span class="sd">                optimal snr of L1.</span>
<span class="sd">            &#39;V1&#39; : `numpy.ndarray` or `float`</span>
<span class="sd">                optimal snr of V1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_snr</span></div>

    
    <span class="nd">@snr</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">snr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snr_finder</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_snr</span> <span class="o">=</span> <span class="n">snr_finder</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unlensed_param</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to get data from the json file self.json_file_names[&quot;unlensed_param&quot;].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;unlensed_param&quot;</span><span class="p">])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">unlensed_param_detectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to get data from the json file self.json_file_names[&quot;unlensed_param_detectable&quot;].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param_detectable : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;unlensed_param_detectable&quot;</span><span class="p">])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lensed_param</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to get data from the json file self.json_file_names[&quot;lensed_param&quot;].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;lensed_param&quot;</span><span class="p">])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lensed_param_detectable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to get data from the json file self.json_file_names[&quot;lensed_param_detectable&quot;].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param_detectable : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;lensed_param_detectable&quot;</span><span class="p">])</span>

<div class="viewcode-block" id="LeR.class_initialization">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.class_initialization">[docs]</a>
    <span class="k">def</span> <span class="nf">class_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to initialize the parent classes. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : `dict`</span>
<span class="sd">            dictionary of parameters to initialize the parent classes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialization of LensGalaxyParameterDistribution class</span>
        <span class="c1"># it also initializes the CBCSourceParameterDistribution and ImageProperties classes</span>
        <span class="n">input_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="c1"># LensGalaxyParameterDistribution class params</span>
            <span class="n">z_min</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">,</span>
            <span class="n">z_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">,</span>
            <span class="n">cosmology</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cosmo</span><span class="p">,</span>
            <span class="n">event_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">event_type</span><span class="p">,</span>
            <span class="n">lens_type</span><span class="o">=</span><span class="s2">&quot;epl_shear_galaxy&quot;</span><span class="p">,</span>
            <span class="n">lens_functions</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">lens_functions_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">lens_param_samplers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">lens_param_samplers_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">buffer_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
            <span class="c1"># ImageProperties class params</span>
            <span class="n">n_min_images</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
            <span class="n">n_max_images</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
            <span class="n">geocent_time_min</span><span class="o">=</span><span class="mf">1126259462.4</span><span class="p">,</span>
            <span class="n">geocent_time_max</span><span class="o">=</span><span class="mf">1126259462.4</span><span class="o">+</span><span class="mi">365</span><span class="o">*</span><span class="mi">24</span><span class="o">*</span><span class="mi">3600</span><span class="o">*</span><span class="mi">20</span><span class="p">,</span>
            <span class="n">lens_model_list</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;EPL_NUMBA&#39;</span><span class="p">,</span> <span class="s1">&#39;SHEAR&#39;</span><span class="p">],</span>
            <span class="c1"># CBCSourceParameterDistribution class params</span>
            <span class="n">source_priors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">source_priors_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">spin_zero</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">spin_precession</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">directory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolator_directory</span><span class="p">,</span>
            <span class="n">create_new_interpolator</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">input_params</span><span class="p">:</span>
                    <span class="n">input_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span> <span class="o">=</span> <span class="n">input_params</span>
        <span class="c1"># initialization of clasess</span>
        <span class="n">LensGalaxyParameterDistribution</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">z_min</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;z_min&quot;</span><span class="p">],</span>
            <span class="n">z_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;z_max&quot;</span><span class="p">],</span>
            <span class="n">cosmology</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;cosmology&quot;</span><span class="p">],</span>
            <span class="n">event_type</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;event_type&quot;</span><span class="p">],</span>
            <span class="n">lens_type</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_type&quot;</span><span class="p">],</span>
            <span class="n">lens_functions</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_functions&quot;</span><span class="p">],</span>
            <span class="n">lens_functions_params</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_functions_params&quot;</span><span class="p">],</span>
            <span class="n">lens_param_samplers</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers&quot;</span><span class="p">],</span>
            <span class="n">lens_param_samplers_params</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers_params&quot;</span><span class="p">],</span>
            <span class="n">n_min_images</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;n_min_images&quot;</span><span class="p">],</span>
            <span class="n">n_max_images</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;n_max_images&quot;</span><span class="p">],</span>
            <span class="n">geocent_time_min</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;geocent_time_min&quot;</span><span class="p">],</span>
            <span class="n">geocent_time_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;geocent_time_max&quot;</span><span class="p">],</span>
            <span class="n">lens_model_list</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;lens_model_list&quot;</span><span class="p">],</span>
            <span class="n">buffer_size</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;buffer_size&quot;</span><span class="p">],</span>
            <span class="n">source_priors</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;source_priors&quot;</span><span class="p">],</span>
            <span class="n">source_priors_params</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;source_priors_params&quot;</span><span class="p">],</span>
            <span class="n">spin_zero</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;spin_zero&quot;</span><span class="p">],</span>
            <span class="n">spin_precession</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;spin_precession&quot;</span><span class="p">],</span>
            <span class="n">directory</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;directory&quot;</span><span class="p">],</span>
            <span class="n">create_new_interpolator</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;source_priors&quot;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;source_priors_params&quot;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers&quot;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;lens_param_samplers_params&quot;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_param_samplers_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;lens_functions&quot;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_functions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="p">[</span><span class="s2">&quot;lens_functions_params&quot;</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lens_functions_params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="LeR.gwsnr_initialization">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.gwsnr_initialization">[docs]</a>
    <span class="k">def</span> <span class="nf">gwsnr_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to initialize the GWSNR class from the `gwsnr` package.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        params : `dict`</span>
<span class="sd">            dictionary of parameters to initialize the gwsnr class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">gwsnr</span> <span class="kn">import</span> <span class="n">GWSNR</span>

        <span class="c1"># initialization of GWSNR class</span>
        <span class="n">input_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">npool</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">npool</span><span class="p">,</span>
            <span class="n">mtot_min</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s1">&#39;source_frame_masses&#39;</span><span class="p">][</span><span class="s1">&#39;mminbh&#39;</span><span class="p">],</span>
            <span class="n">mtot_max</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">gw_param_samplers_params</span><span class="p">[</span><span class="s1">&#39;source_frame_masses&#39;</span><span class="p">][</span><span class="s1">&#39;mmaxbh&#39;</span><span class="p">]</span><span class="o">+</span><span class="mf">10.0</span><span class="p">,</span>
            <span class="n">ratio_min</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
            <span class="n">ratio_max</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
            <span class="n">spin_max</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span>
            <span class="n">mtot_resolution</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
            <span class="n">ratio_resolution</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
            <span class="n">spin_resolution</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
            <span class="n">sampling_frequency</span><span class="o">=</span><span class="mf">2048.0</span><span class="p">,</span>
            <span class="n">waveform_approximant</span><span class="o">=</span><span class="s2">&quot;IMRPhenomD&quot;</span><span class="p">,</span>
            <span class="n">frequency_domain_source_model</span><span class="o">=</span><span class="s1">&#39;lal_binary_black_hole&#39;</span><span class="p">,</span>
            <span class="n">minimum_frequency</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span>
            <span class="n">duration_max</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">duration_min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">snr_type</span><span class="o">=</span><span class="s2">&quot;interpolation&quot;</span><span class="p">,</span>
            <span class="n">psds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ifos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">interpolator_dir</span><span class="o">=</span><span class="s2">&quot;./interpolator_pickle&quot;</span><span class="p">,</span>
            <span class="n">create_new_interpolator</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">gwsnr_verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">multiprocessing_verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">mtot_cut</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">pdet</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">snr_th</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
            <span class="n">snr_th_net</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
            <span class="n">ann_path_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">snr_recalculation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">snr_recalculation_range</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">12</span><span class="p">],</span>
            <span class="n">snr_recalculation_waveform_approximant</span><span class="o">=</span><span class="s2">&quot;IMRPhenomXPHM&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># if self.event_type == &quot;BNS&quot;:</span>
        <span class="c1">#     input_params[&quot;mtot_max&quot;]= 18.</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">input_params</span><span class="p">:</span>
                    <span class="n">input_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span> <span class="o">=</span> <span class="n">input_params</span>

        <span class="c1"># dealing with create_new_interpolator param</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># check input_params[&quot;gwsnr&quot;] exists</span>
            <span class="k">if</span> <span class="s2">&quot;gwsnr&quot;</span> <span class="ow">in</span> <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">][</span><span class="s2">&quot;gwsnr&quot;</span><span class="p">],</span> <span class="nb">bool</span><span class="p">):</span>
                    <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">][</span><span class="s2">&quot;gwsnr&quot;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;create_new_interpolator[&#39;gwsnr&#39;] should be a boolean.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># initialization of GWSNR class</span>
        <span class="n">gwsnr</span> <span class="o">=</span> <span class="n">GWSNR</span><span class="p">(</span>
                    <span class="n">npool</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;npool&quot;</span><span class="p">],</span>
                    <span class="n">mtot_min</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;mtot_min&quot;</span><span class="p">],</span>
                    <span class="n">mtot_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;mtot_max&quot;</span><span class="p">],</span>
                    <span class="n">ratio_min</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ratio_min&quot;</span><span class="p">],</span>
                    <span class="n">ratio_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ratio_max&quot;</span><span class="p">],</span>
                    <span class="n">spin_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;spin_max&quot;</span><span class="p">],</span>
                    <span class="n">mtot_resolution</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;mtot_resolution&quot;</span><span class="p">],</span>
                    <span class="n">ratio_resolution</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ratio_resolution&quot;</span><span class="p">],</span>
                    <span class="n">spin_resolution</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;spin_resolution&quot;</span><span class="p">],</span>
                    <span class="n">sampling_frequency</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;sampling_frequency&quot;</span><span class="p">],</span>
                    <span class="n">waveform_approximant</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;waveform_approximant&quot;</span><span class="p">],</span>
                    <span class="n">frequency_domain_source_model</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;frequency_domain_source_model&quot;</span><span class="p">],</span>
                    <span class="n">minimum_frequency</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;minimum_frequency&quot;</span><span class="p">],</span>
                    <span class="n">duration_max</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;duration_max&quot;</span><span class="p">],</span>
                    <span class="n">duration_min</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;duration_min&quot;</span><span class="p">],</span>
                    <span class="n">snr_type</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;snr_type&quot;</span><span class="p">],</span>
                    <span class="n">psds</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;psds&quot;</span><span class="p">],</span>
                    <span class="n">ifos</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ifos&quot;</span><span class="p">],</span>
                    <span class="n">interpolator_dir</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;interpolator_dir&quot;</span><span class="p">],</span>
                    <span class="n">create_new_interpolator</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;create_new_interpolator&quot;</span><span class="p">],</span>
                    <span class="n">gwsnr_verbose</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;gwsnr_verbose&quot;</span><span class="p">],</span>
                    <span class="n">multiprocessing_verbose</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;multiprocessing_verbose&quot;</span><span class="p">],</span>
                    <span class="n">mtot_cut</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;mtot_cut&quot;</span><span class="p">],</span>
                    <span class="n">pdet</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;pdet&quot;</span><span class="p">],</span>
                    <span class="n">snr_th</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;snr_th&quot;</span><span class="p">],</span>      
                    <span class="n">snr_th_net</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;snr_th_net&quot;</span><span class="p">],</span>
                    <span class="n">ann_path_dict</span><span class="o">=</span><span class="n">input_params</span><span class="p">[</span><span class="s2">&quot;ann_path_dict&quot;</span><span class="p">],</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">snr</span> <span class="o">=</span> <span class="n">gwsnr</span><span class="o">.</span><span class="n">snr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_of_detectors</span> <span class="o">=</span> <span class="n">gwsnr</span><span class="o">.</span><span class="n">detector_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_bilby</span> <span class="o">=</span> <span class="n">gwsnr</span><span class="o">.</span><span class="n">compute_bilby_snr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s2">&quot;mtot_max&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gwsnr</span><span class="o">.</span><span class="n">mtot_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="p">[</span><span class="s2">&quot;psds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gwsnr</span><span class="o">.</span><span class="n">psds_list</span></div>

        <span class="c1">#self.pdet = gwsnr.pdet</span>

<div class="viewcode-block" id="LeR.store_ler_params">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.store_ler_params">[docs]</a>
    <span class="k">def</span> <span class="nf">store_ler_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="o">=</span><span class="s2">&quot;ler_params.json&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to store the all the necessary parameters. This is useful for reproducing the results. All the parameters stored are in string format to make it json compatible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            name of the json file to store the parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># store param_sampler_dict, lensed_param_sampler_dict and snr_calculator_dict</span>
        <span class="n">parameters_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">npool</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">npool</span><span class="p">),</span>
            <span class="n">z_min</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_min</span><span class="p">),</span>
            <span class="n">z_max</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">z_max</span><span class="p">),</span>
            <span class="n">size</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">),</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">),</span>
            <span class="n">cosmology</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cosmo</span><span class="p">),</span>
            <span class="n">snr_finder</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">),</span>
            <span class="n">json_file_names</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">),</span>
            <span class="n">interpolator_directory</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">interpolator_directory</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># cbc params</span>
        <span class="n">param_sampler_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gw_param_sampler_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># convert all dict values to str</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param_sampler_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">param_sampler_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">parameters_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;gw_param_sampler_dict&quot;</span><span class="p">:</span> <span class="n">param_sampler_dict</span><span class="p">})</span>

        <span class="c1"># snr calculator params</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">snr_calculator_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_calculator_dict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">snr_calculator_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">snr_calculator_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">parameters_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;snr_calculator_dict&quot;</span><span class="p">:</span> <span class="n">snr_calculator_dict</span><span class="p">})</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="c1"># if snr_calculator is custom function</span>
            <span class="k">pass</span>
        
        <span class="n">file_name</span> <span class="o">=</span> <span class="n">output_jsonfile</span>
        <span class="n">append_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">file_name</span><span class="p">,</span> <span class="n">parameters_dict</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="LeR.unlensed_cbc_statistics">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.unlensed_cbc_statistics">[docs]</a>
    <span class="k">def</span> <span class="nf">unlensed_cbc_statistics</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate unlensed GW source parameters. This function calls the unlensed_sampling_routine function to generate the parameters in batches. The generated parameters are stored in a json file; and if save_batch=True, it keeps updating the file in batches.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">            default size = 100000.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            resume = False (default) or True.</span>
<span class="sd">            if True, the function will resume from the last batch.</span>
<span class="sd">        save_batch : `bool`</span>
<span class="sd">            if True, the function will save the parameters in batches. if False (default), the function will save all the parameters at the end of sampling. save_batch=False is faster.</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters.</span>
<span class="sd">            default output_jsonfile = &#39;unlensed_params.json&#39;. Note that this file will be stored in the self.ler_directory.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters. Refer to :attr:`~unlensed_param` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; unlensed_param = ler.unlensed_cbc_statistics()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">output_jsonfile</span> <span class="o">=</span> <span class="n">output_jsonfile</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;unlensed_param&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;unlensed_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_jsonfile</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unlensed params will be stored in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">unlensed_param</span> <span class="o">=</span> <span class="n">batch_handler</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">sampling_routine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">unlensed_sampling_routine</span><span class="p">,</span>
            <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">output_path</span><span class="p">,</span>
            <span class="n">save_batch</span><span class="o">=</span><span class="n">save_batch</span><span class="p">,</span>
            <span class="n">resume</span><span class="o">=</span><span class="n">resume</span><span class="p">,</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;unlensed parameters&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">unlensed_param</span></div>

    
<div class="viewcode-block" id="LeR.unlensed_sampling_routine">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.unlensed_sampling_routine">[docs]</a>
    <span class="k">def</span> <span class="nf">unlensed_sampling_routine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_batch</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate unlensed GW source parameters. This function also stores the parameters in json file in the current batch if save_batch=True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">            default size = 100000.</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters.</span>
<span class="sd">            default output_jsonfile = &#39;unlensed_params.json&#39;. Note that this file will be stored in the self.ler_directory.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            resume = False (default) or True. </span>
<span class="sd">            if True, it appends the new samples to the existing json file.</span>
<span class="sd">        save_batch : `bool`</span>
<span class="sd">            if True, the function will save the parameters in batches. if False, the function will save all the parameters at the end of sampling. save_batch=False is faster.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters. Refer to :attr:`~unlensed_param` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get gw params</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sampling gw source params...&quot;</span><span class="p">)</span>
        <span class="n">unlensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_gw_parameters</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># Get all of the signal to noise ratios</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating snrs...&quot;</span><span class="p">)</span>
            <span class="n">snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">(</span><span class="n">gw_param_dict</span><span class="o">=</span><span class="n">unlensed_param</span><span class="p">)</span>
            <span class="n">unlensed_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">snrs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdet</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating pdet...&quot;</span><span class="p">)</span>
            <span class="n">pdet</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdet</span><span class="p">(</span><span class="n">gw_param_dict</span><span class="o">=</span><span class="n">unlensed_param</span><span class="p">)</span>
            <span class="n">unlensed_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pdet</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unlensed_param</span></div>


<div class="viewcode-block" id="LeR.unlensed_rate">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.unlensed_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">unlensed_rate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">unlensed_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">snr_threshold</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="n">pdet_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">detectability_condition</span><span class="o">=</span><span class="s2">&quot;step_function&quot;</span><span class="p">,</span>
        <span class="n">snr_recalculation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snr_threshold_recalculation</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate the unlensed rate. This function also stores the parameters of the detectable events in json file. There are two conditions for detectability: &#39;step_function&#39; and &#39;pdet&#39;.</span>

<span class="sd">        1. &#39;step_function&#39;: If two images have SNR&gt;8.0, then the event is detectable. This is a step function. This is with the assumption that SNR function is provided and not None. </span>
<span class="sd">        2. &#39;pdet&#39;:</span>
<span class="sd">            i) If self.pdet is None and self.snr is not None, then it will calculate the pdet from the snr. There is no hard cut for this pdet and can have value ranging from 0 to 1 near the threshold.</span>
<span class="sd">            ii) If self.pdet is not None, then it will use the generated pdet.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param : `dict` or `str`</span>
<span class="sd">            dictionary of GW source parameters or json file name.</span>
<span class="sd">            default unlensed_param = &#39;unlensed_params.json&#39;.</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            e.g. snr_threshold = 8.</span>
<span class="sd">        pdet_threshold : `float`</span>
<span class="sd">            threshold for detection probability.</span>
<span class="sd">            e.g. pdet_threshold = 0.5.</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters of the detectable events.</span>
<span class="sd">            default output_jsonfile = &#39;unlensed_params_detectable.json&#39;.</span>
<span class="sd">        detectability_condition : `str`</span>
<span class="sd">            detectability condition. </span>
<span class="sd">            default detectability_condition = &#39;step_function&#39;.</span>
<span class="sd">            other options are &#39;pdet&#39;.</span>
<span class="sd">        snr_recalculation : `bool`</span>
<span class="sd">            if True, the SNR of centain events (snr&gt;snr_threshold_recalculation)will be recalculate with &#39;inner-product&#39; method. This is useful when the snr is calculated with &#39;ann&#39; method of `gwsnr`.</span>
<span class="sd">            default snr_recalculation = False.</span>
<span class="sd">        snr_threshold_recalculation : `list`</span>
<span class="sd">            lower and upper threshold for recalculation of detection signal to noise ratio.</span>
<span class="sd">            default snr_threshold_recalculation = [4, 20].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        total_rate : `float`</span>
<span class="sd">            total unlensed rate (Mpc^-3 yr^-1).</span>
<span class="sd">        unlensed_param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters of the detectable events. Refer to :attr:`~unlensed_param` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; ler.unlensed_cbc_statistics();</span>
<span class="sd">        &gt;&gt;&gt; total_rate, unlensed_param_detectable = ler.unlensed_rate()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">unlensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_param</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">)</span>
        <span class="n">total_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>

        <span class="c1"># below is use when the snr is calculated with &#39;ann&#39; method of `gwsnr`</span>
        <span class="k">if</span> <span class="n">snr_recalculation</span><span class="p">:</span>
            <span class="n">unlensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recalculate_snr_unlensed</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">,</span> <span class="n">snr_threshold_recalculation</span><span class="p">)</span>

        <span class="c1"># find index of detectable events</span>
        <span class="n">idx_detectable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_detectable_index_unlensed</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="p">)</span>

        <span class="n">detectable_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx_detectable</span><span class="p">)</span>
        <span class="c1"># montecarlo integration</span>
        <span class="c1"># The total rate R = norm &lt;Theta(rho-rhoc)&gt;</span>
        <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span><span class="n">detectable_events</span><span class="p">,</span> <span class="n">total_events</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">)</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_detectable_params</span><span class="p">(</span><span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">unlensed_param</span><span class="p">,</span> <span class="n">idx_detectable</span><span class="p">,</span> <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;unlensed_param_detectable&quot;</span><span class="p">,</span> <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># append ler_param and save it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_ler_param</span><span class="p">(</span><span class="n">total_rate</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">total_rate</span><span class="p">,</span> <span class="n">unlensed_param</span></div>


    <span class="k">def</span> <span class="nf">_load_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to load or copy unlensed parameters.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param : `dict` or `str`</span>
<span class="sd">            dictionary of unlensed/lensed parameters or json file name.</span>
<span class="sd">        param_type : `str`</span>
<span class="sd">            type of parameters.</span>
<span class="sd">            default param_type = &#39;unlensed&#39;. Other options is &#39;lensed&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        param : `dict`</span>
<span class="sd">            dictionary of unlensed/lensed parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">param_type</span> <span class="o">=</span> <span class="n">param_type</span><span class="o">+</span><span class="s2">&quot;_param&quot;</span>
        <span class="k">if</span> <span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="n">param_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">path_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">param</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Getting </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> from json file </span><span class="si">{</span><span class="n">path_</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">path_</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using provided </span><span class="si">{param_type}</span><span class="s2"> dict...&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">param</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_recalculate_snr_unlensed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unlensed_param</span><span class="p">,</span> <span class="n">snr_threshold_recalculation</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recalculates SNR for events where the initial SNR is above a given threshold.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ---------- </span>
<span class="sd">        unlensed_param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">        snr_threshold_recalculation : `list`</span>
<span class="sd">            lower and upper threshold for recalculation of detection signal to noise ratio.</span>
<span class="sd">            default snr_threshold_recalculation = [4, 20].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">snr_param</span> <span class="o">=</span> <span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;optimal_snr_net&quot;</span><span class="p">]</span>
        <span class="n">idx_detectable</span> <span class="o">=</span> <span class="p">(</span><span class="n">snr_param</span> <span class="o">&gt;</span> <span class="n">snr_threshold_recalculation</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">snr_param</span> <span class="o">&lt;</span> <span class="n">snr_threshold_recalculation</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># reduce the size of the dict</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">unlensed_param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">unlensed_param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">idx_detectable</span><span class="p">]</span>
        <span class="c1"># recalculate more accurate snrs </span>
        <span class="n">snrs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr_bilby</span><span class="p">(</span><span class="n">gw_param_dict</span><span class="o">=</span><span class="n">unlensed_param</span><span class="p">)</span>
        <span class="n">unlensed_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">snrs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">unlensed_param</span>

    <span class="k">def</span> <span class="nf">_find_detectable_index_unlensed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unlensed_param</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the index of detectable events based on SNR or p_det.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters.</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">        pdet_threshold : `float`</span>
<span class="sd">            threshold for detection probability.</span>
<span class="sd">        detectability_condition : `str`</span>
<span class="sd">            detectability condition.</span>
<span class="sd">            default detectability_condition = &#39;step_function&#39;.</span>
<span class="sd">            other options are &#39;pdet&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        idx_detectable : `numpy.ndarray`</span>
<span class="sd">            index of detectable events.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;optimal_snr_net&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unlensed_param</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;optimal_snr_net&#39; not in unlensed param dict provided&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;step_function&quot;</span><span class="p">:</span>
                <span class="c1">#print(&quot;given detectability_condition == &#39;step_function&#39;&quot;)</span>
                <span class="n">param</span> <span class="o">=</span> <span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;optimal_snr_net&quot;</span><span class="p">]</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">snr_threshold</span>
            <span class="k">elif</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;pdet&quot;</span><span class="p">:</span>
                <span class="c1">#print(&quot;given detectability_condition == &#39;pdet&#39;&quot;)</span>
                <span class="n">param</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">snr_threshold</span> <span class="o">-</span> <span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;optimal_snr_net&quot;</span><span class="p">])</span>
                <span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">pdet_threshold</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdet</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;pdet_net&quot;</span> <span class="ow">in</span> <span class="n">unlensed_param</span><span class="p">:</span>
                <span class="c1">#print(&quot;given detectability_condition == &#39;pdet&#39;&quot;)</span>
                <span class="n">param</span> <span class="o">=</span> <span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">pdet_threshold</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;pdet_net&#39; not in unlensed param dict provided&quot;</span><span class="p">)</span>

        <span class="n">idx_detectable</span> <span class="o">=</span> <span class="n">param</span> <span class="o">&gt;</span> <span class="n">threshold</span>
        <span class="k">return</span> <span class="n">idx_detectable</span>

<div class="viewcode-block" id="LeR.rate_function">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.rate_function">[docs]</a>
    <span class="k">def</span> <span class="nf">rate_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detectable_size</span><span class="p">,</span> <span class="n">total_size</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        General helper function to calculate the rate for unlensed and lensed events.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        detectable_size : `int`</span>
<span class="sd">            number of detectable events.</span>
<span class="sd">        total_size : `int`</span>
<span class="sd">            total number of events.</span>
<span class="sd">        param_type : `str`</span>
<span class="sd">            type of parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        rate : `float`</span>
<span class="sd">            rate of the events.</span>

<span class="sd">        Examples</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; rate = ler.rate_function(detectable_size=100, total_size=1000)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">param_type</span> <span class="o">==</span> <span class="s2">&quot;unlensed&quot;</span><span class="p">:</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_pdf_z</span>
        <span class="k">elif</span> <span class="n">param_type</span> <span class="o">==</span> <span class="s2">&quot;lensed&quot;</span><span class="p">:</span>
            <span class="n">normalization</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalization_pdf_z_lensed</span>
        <span class="n">rate</span> <span class="o">=</span> <span class="n">normalization</span> <span class="o">*</span> <span class="n">detectable_size</span> <span class="o">/</span> <span class="n">total_size</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> rate (yr^-1): </span><span class="si">{</span><span class="n">rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;number of simulated </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> detectable events: </span><span class="si">{</span><span class="n">detectable_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;number of simulated all </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> events: </span><span class="si">{</span><span class="n">total_size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">rate</span></div>


    <span class="k">def</span> <span class="nf">_save_detectable_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="p">,</span>
        <span class="n">param</span><span class="p">,</span> 
        <span class="n">idx_detectable</span><span class="p">,</span> 
        <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;unlensed_param_detectable&quot;</span><span class="p">,</span>
        <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to save the detectable parameters in json file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters of the detectable events. This is stored in the self.ler_directory.</span>
<span class="sd">        param : `dict`</span>
<span class="sd">            dictionary of GW source parameters.</span>
<span class="sd">        idx_detectable : `numpy.ndarray`</span>
<span class="sd">            index of detectable events.</span>
<span class="sd">        key_file_name : `str`</span>
<span class="sd">            key name for the json file to be added in self.json_file_names.</span>
<span class="sd">        nan_to_num : `bool`</span>
<span class="sd">            if True, it will replace nan with 0.</span>
<span class="sd">            default nan_to_num = False.</span>
<span class="sd">        verbose : `bool`</span>
<span class="sd">            if True, it will print the path of the json file.</span>
<span class="sd">            default verbose = True.</span>
<span class="sd">        replace_jsonfile : `bool`</span>
<span class="sd">            if True, it will replace the json file. If False, it will append the json file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="k">if</span> <span class="n">nan_to_num</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="n">idx_detectable</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">idx_detectable</span><span class="p">]</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="k">if</span> <span class="n">output_jsonfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_jsonfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="n">key_file_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="n">key_file_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_jsonfile</span>

        <span class="n">output_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">output_jsonfile</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;storing detectable params in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="n">replace_jsonfile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_append_ler_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total_rate</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to append the final results, total_rate, in the json file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        total_rate : `float`</span>
<span class="sd">            total rate.</span>
<span class="sd">        detectability_condition : `str`</span>
<span class="sd">            detectability condition.</span>
<span class="sd">        param_type : `str`</span>
<span class="sd">            type of parameters.</span>
<span class="sd">            default param_type = &#39;unlensed&#39;. Other options is &#39;lensed&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>
        <span class="c1"># write the results</span>
        <span class="n">data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;detectable_</span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2">_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>
        <span class="n">data</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;detectability_condition+</span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectability_condition</span>
        <span class="n">append_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
<div class="viewcode-block" id="LeR.lensed_cbc_statistics">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.lensed_cbc_statistics">[docs]</a>
    <span class="k">def</span> <span class="nf">lensed_cbc_statistics</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate lensed GW source parameters. This function calls the lensed_sampling_routine function to generate the parameters in batches. The generated parameters are stored in a json file; and if save_batch=True, it keeps updating the file in batches.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">            default size = 100000.</span>
<span class="sd">        save_batch : `bool`</span>
<span class="sd">            if True, the function will save the parameters in batches. if False, the function will save all the parameters at the end of sampling. save_batch=False is faster.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            resume = False (default) or True.</span>
<span class="sd">            if True, the function will resume from the last batch.</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters.</span>
<span class="sd">            default output_jsonfile = &#39;lensed_params.json&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters. Refer to :attr:`~lensed_param` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; lensed_param = ler.lensed_cbc_statistics()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="n">output_jsonfile</span> <span class="o">=</span> <span class="n">output_jsonfile</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;lensed_param&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;lensed_param&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">output_jsonfile</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lensed params will be store in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">lensed_param</span> <span class="o">=</span> <span class="n">batch_handler</span><span class="p">(</span>
            <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span>
            <span class="n">batch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
            <span class="n">sampling_routine</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lensed_sampling_routine</span><span class="p">,</span>
            <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">output_path</span><span class="p">,</span>
            <span class="n">save_batch</span><span class="o">=</span><span class="n">save_batch</span><span class="p">,</span>
            <span class="n">resume</span><span class="o">=</span><span class="n">resume</span><span class="p">,</span>
            <span class="n">param_name</span><span class="o">=</span><span class="s2">&quot;lensed parameters&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">lensed_param</span></div>

    
<div class="viewcode-block" id="LeR.lensed_sampling_routine">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.lensed_sampling_routine">[docs]</a>
    <span class="k">def</span> <span class="nf">lensed_sampling_routine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">save_batch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate lensed GW source parameters. This function also stores the parameters in json file in the current batch if save_batch=True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">            default size = 100000.</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters.</span>
<span class="sd">            default output_jsonfile = &#39;lensed_params.json&#39;. Note that this file will be stored in the self.ler_directory.</span>
<span class="sd">        save_batch : `bool`</span>
<span class="sd">            if True, the function will save the parameters in batches. if False, the function will save all the parameters at the end of sampling. save_batch=False is faster.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            resume = False (default) or True.</span>
<span class="sd">            if True, it appends the new samples to the existing json file.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters. Refer to :attr:`~lensed_param` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sampling lensed params...&quot;</span><span class="p">)</span>
        <span class="n">lensed_param</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Some of the sample lensed events may not satisfy the strong lensing condition</span>
        <span class="c1"># In that case, we will resample those events and replace the values with the corresponding indices</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># get lensed params</span>
            <span class="n">lensed_param_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_lens_parameters</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
            <span class="c1"># now get (strongly lensed) image paramters along with lens parameters</span>
            <span class="n">lensed_param_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_properties</span><span class="p">(</span><span class="n">lensed_param_</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if empty</span>
                    <span class="n">lensed_param</span> <span class="o">=</span> <span class="n">lensed_param_</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># below will not be used in the first iteration</span>
                <span class="c1"># replace the values of the keys</span>
                <span class="c1"># idx defines the position that does not satisfy the strong lensing condition</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lensed_param_</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">lensed_param</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="c1"># check for invalid samples</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;n_images&quot;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid sample found. Resampling </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="si">}</span><span class="s2"> lensed events...&quot;</span><span class="p">)</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                
        <span class="c1"># Get all of the signal to noise ratios</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating snrs...&quot;</span><span class="p">)</span>
            <span class="n">snrs</span><span class="p">,</span> <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lensed_snrs</span><span class="p">(</span>
                <span class="n">lensed_param</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span>
                <span class="n">list_of_detectors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">list_of_detectors</span><span class="p">,</span>
                <span class="n">snr_calculator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snr</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">lensed_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">snrs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pdet</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating pdet...&quot;</span><span class="p">)</span>
            <span class="n">pdet</span><span class="p">,</span> <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lensed_snrs</span><span class="p">(</span>
                <span class="n">lensed_param</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span>
                <span class="n">list_of_detectors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">list_of_detectors</span><span class="p">,</span>
                <span class="n">pdet_calculator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pdet</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">lensed_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">pdet</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lensed_param</span></div>


<div class="viewcode-block" id="LeR.lensed_rate">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.lensed_rate">[docs]</a>
    <span class="k">def</span> <span class="nf">lensed_rate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lensed_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">snr_threshold</span><span class="o">=</span><span class="p">[</span><span class="mf">8.0</span><span class="p">,</span><span class="mf">8.0</span><span class="p">],</span>
        <span class="n">pdet_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">num_img</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">detectability_condition</span><span class="o">=</span><span class="s2">&quot;step_function&quot;</span><span class="p">,</span>
        <span class="n">combine_image_snr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snr_cut_for_combine_image_snr</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
        <span class="n">snr_recalculation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snr_threshold_recalculation</span><span class="o">=</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">]],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate the lensed rate. This function also stores the parameters of the detectable events in json file. There are two conditions for detectability: &#39;step_function&#39; and &#39;pdet&#39;.</span>

<span class="sd">        1. &#39;step_function&#39;: If two images have SNR&gt;8.0, then the event is detectable. This is a step function. This is with the assumption that SNR function is provided and not None. </span>
<span class="sd">        2. &#39;pdet&#39;: </span>
<span class="sd">            i) If self.pdet is None and self.snr is not None, then it will calculate the pdet from the snr. There is no hard cut for this pdet and can have value ranging from 0 to 1 near the threshold.</span>
<span class="sd">            ii) If self.pdet is not None, then it will use the generated pdet.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict` or `str`</span>
<span class="sd">            dictionary of GW source parameters or json file name.</span>
<span class="sd">            default lensed_param = &#39;lensed_params.json&#39;.</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio. This is use when self.snr is provided.</span>
<span class="sd">            default snr_threshold = [8.0,8.0].</span>
<span class="sd">        pdet_threshold : `float`</span>
<span class="sd">            threshold for detection probability. This is use when self.pdet is provided.</span>
<span class="sd">            default pdet_threshold = 0.5.</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images corresponding to the snr_threshold.</span>
<span class="sd">            default num_img = [1,1]. Together with snr_threshold = [8.0,8.0], it means that two images with snr&gt;8.0. Same condition can also be represented by snr_threshold = 8.0 and num_img = 2.</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters of the detectable events.</span>
<span class="sd">            default output_jsonfile = &#39;lensed_params_detectable.json&#39;.</span>
<span class="sd">        nan_to_num : `bool`</span>
<span class="sd">            if True, nan values will be converted to 0.</span>
<span class="sd">            default nan_to_num = True.</span>
<span class="sd">        detectability_condition : `str`</span>
<span class="sd">            detectability condition.</span>
<span class="sd">            default detectability_condition = &#39;step_function&#39;.</span>
<span class="sd">            other options are &#39;pdet&#39;.</span>
<span class="sd">        snr_recalculation : `bool`</span>
<span class="sd">            if True, the SNR of centain events (snr&gt;snr_threshold_recalculation)will be recalculate with &#39;inner-product&#39; method. This is useful when the snr is calculated with &#39;ann&#39; method of `gwsnr`.</span>
<span class="sd">            default snr_recalculation = False.</span>
<span class="sd">        snr_threshold_recalculation : `list`</span>
<span class="sd">            lower and upper threshold for recalculation of detection signal to noise ratio.</span>
<span class="sd">            default snr_threshold_recalculation = [[4,4], [20,20]].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        total_rate : `float`</span>
<span class="sd">            total lensed rate (Mpc^-3 yr^-1).</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters of the detectable events. Refer to :attr:`~lensed_param` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; ler.lensed_cbc_statistics();</span>
<span class="sd">        &gt;&gt;&gt; total_rate, lensed_param_detectable = ler.lensed_rate()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># load lensed parameters</span>
        <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_param</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span><span class="p">)</span>

        <span class="c1"># re-analyse the provided snr_threshold and num_img</span>
        <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">num_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_snr_threshold_lensed</span><span class="p">(</span><span class="n">snr_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">)</span>

        <span class="c1"># get size of the lensed_param for a parameter</span>
        <span class="n">total_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>

        <span class="c1"># this ensures that the snr is recalculated for the detectable events</span>
        <span class="c1"># with inner product</span>
        <span class="c1"># below is use when the snr is calculated with &#39;ann&#39; method of `gwsnr`</span>
        <span class="k">if</span> <span class="n">snr_recalculation</span><span class="p">:</span>
            <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recalculate_snr_lensed</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">,</span> <span class="n">snr_threshold_recalculation</span><span class="p">,</span> <span class="n">num_img</span><span class="p">,</span> <span class="n">total_events</span><span class="p">)</span>

        <span class="c1"># find index of detectable events</span>
        <span class="n">snr_hit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_detectable_index_lensed</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="p">,</span> <span class="n">combine_image_snr</span><span class="o">=</span><span class="n">combine_image_snr</span><span class="p">,</span> <span class="n">snr_cut_for_combine_image_snr</span><span class="o">=</span><span class="n">snr_cut_for_combine_image_snr</span><span class="p">)</span>

        <span class="c1"># select according to time delay</span>

        <span class="c1"># montecarlo integration</span>
        <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">snr_hit</span><span class="p">),</span> <span class="n">total_events</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span><span class="p">)</span>

        <span class="c1"># store all detectable params in json file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_detectable_params</span><span class="p">(</span><span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">lensed_param</span><span class="p">,</span> <span class="n">snr_hit</span><span class="p">,</span> <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;lensed_param_detectable&quot;</span><span class="p">,</span> <span class="n">nan_to_num</span><span class="o">=</span><span class="n">nan_to_num</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># append ler_param and save it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_ler_param</span><span class="p">(</span><span class="n">total_rate</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">total_rate</span><span class="p">,</span> <span class="n">lensed_param</span></div>


    <span class="k">def</span> <span class="nf">_check_snr_threshold_lensed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to check the snr_threshold and num_img for lensed events.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            default snr_threshold = [8.0,8.0].</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images corresponding to the snr_threshold.</span>
<span class="sd">            default num_img = [1,1]. Together with snr_threshold = [8.0,8.0], it means that two images with snr&gt;8.0. Same condition can also be represented by snr_threshold = 8.0 and num_img = 2.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images corresponding to the snr_threshold.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check for images with snr above threshold</span>
        <span class="c1"># convert to array</span>
        <span class="n">snr_threshold_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">snr_threshold</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  
        <span class="n">num_img_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">num_img</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># get descending sorted idx of snr_threshold</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">snr_threshold_</span><span class="p">)</span>
        <span class="n">snr_threshold</span> <span class="o">=</span> <span class="n">snr_threshold_</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">num_img</span> <span class="o">=</span> <span class="n">num_img_</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">num_img</span>

    <span class="k">def</span> <span class="nf">_recalculate_snr_lensed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lensed_param</span><span class="p">,</span> <span class="n">snr_threshold_recalculation</span><span class="p">,</span> <span class="n">num_img</span><span class="p">,</span> <span class="n">total_events</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to recalculate the SNR of lensed events with SNR above a given threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters.</span>
<span class="sd">        snr_threshold_recalculation : `list`</span>
<span class="sd">            lower and upper threshold for recalculation of detection signal to noise ratio.</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images corresponding to the snr_threshold.</span>
<span class="sd">        total_events : `int`</span>
<span class="sd">            total number of events.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># dealing with provided snr_threshold_recalculation</span>
        <span class="n">snr_threshold_recalculation_min</span><span class="p">,</span> <span class="n">num_img_recalculation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_snr_threshold_lensed</span><span class="p">(</span><span class="n">snr_threshold_recalculation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_img</span><span class="p">)</span>
        <span class="n">snr_threshold_recalculation_max</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_snr_threshold_lensed</span><span class="p">(</span><span class="n">snr_threshold_recalculation</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">num_img</span><span class="p">)</span>

        <span class="c1"># check optimal_snr_net is provided in dict</span>
        <span class="k">if</span> <span class="s2">&quot;optimal_snr_net&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lensed_param</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;optimal_snr_net not provided in lensed_param dict. Exiting...&quot;</span><span class="p">)</span>

        <span class="n">snr_param</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;optimal_snr_net&quot;</span><span class="p">]</span>
        <span class="n">snr_param</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">snr_param</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sort snr in descending order</span>
            
        <span class="c1"># for each row: choose a threshold and check if the number of images above threshold. Sum over the images. If sum is greater than num_img, then snr_hit = True</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">idx_max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">total_events</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># boolean array to store the result of the threshold condition</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">snr_th_min</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">snr_threshold_recalculation_min</span><span class="p">):</span>
            <span class="n">snr_th_max</span> <span class="o">=</span> <span class="n">snr_threshold_recalculation_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">idx_max</span> <span class="o">=</span> <span class="n">idx_max</span> <span class="o">+</span> <span class="n">num_img_recalculation</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">snr_hit</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">snr_param</span><span class="p">[:,</span><span class="n">j</span><span class="p">:</span><span class="n">idx_max</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_th_min</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">snr_param</span><span class="p">[:,</span><span class="n">j</span><span class="p">:</span><span class="n">idx_max</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">snr_th_max</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">num_img_recalculation</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">idx_max</span>

        <span class="c1"># reduce the size of the dict</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">lensed_param</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">lensed_param</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">snr_hit</span><span class="p">]</span>
        <span class="c1"># recalculate more accurate snrs</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating snrs...&quot;</span><span class="p">)</span>
        <span class="n">snrs</span><span class="p">,</span> <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_lensed_snrs</span><span class="p">(</span>
            <span class="n">snr_calculator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">snr_bilby</span><span class="p">,</span>
            <span class="n">list_of_detectors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">list_of_detectors</span><span class="p">,</span>
            <span class="n">lensed_param</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">lensed_param</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">snrs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lensed_param</span>

    <span class="k">def</span> <span class="nf">_find_detectable_index_lensed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lensed_param</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="p">,</span> <span class="n">combine_image_snr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">snr_cut_for_combine_image_snr</span><span class="o">=</span><span class="mf">4.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function to find the index of detectable events based on SNR or p_det.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters.</span>
<span class="sd">        snr_threshold : `float` or `list`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            default snr_threshold = [8.0,8.0].</span>
<span class="sd">        pdet_threshold : `float` or `list`</span>
<span class="sd">            threshold for detection probability.</span>
<span class="sd">            default pdet_threshold = 0.5.</span>
<span class="sd">        num_img : `int` or `list`</span>
<span class="sd">            number of images corresponding to the snr_threshold.</span>
<span class="sd">            default num_img = [1,1].</span>
<span class="sd">        detectability_condition : `str`</span>
<span class="sd">            detectability condition.</span>
<span class="sd">            default detectability_condition = &#39;step_function&#39;.</span>
<span class="sd">            other options are &#39;pdet&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        snr_hit : `bool`</span>
<span class="sd">            boolean array to store the result of the threshold condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#print(f&quot;given detectability_condition == {detectability_condition}&quot;)</span>
        <span class="k">if</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;step_function&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;optimal_snr_net&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lensed_param</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;optimal_snr_net&#39; not in lensed parm dict provided&quot;</span><span class="p">)</span>
            <span class="n">snr_param</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;optimal_snr_net&quot;</span><span class="p">]</span>
            <span class="n">snr_param</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">snr_param</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sort snr in descending order</span>
            <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snr_param</span><span class="p">),</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># boolean array to store the result of the threshold condition</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">combine_image_snr</span><span class="p">:</span>
                <span class="c1"># for each row: choose a threshold and check if the number of images above threshold. Sum over the images. If sum is greater than num_img, then snr_hit = True </span>
                <span class="c1"># algorithm: </span>
                <span class="c1"># i) consider snr_threshold=[8,6] and num_img=[2,1] and first row of snr_param[0]=[12,8,6,1]. Note that the snr_param is sorted in descending order.</span>
                <span class="c1"># ii) for loop runs wrt snr_threshold. idx_max = idx_max + num_img[i]</span>
                <span class="c1"># iii) First iteration: snr_threshold=8 and num_img=2. In snr_param, column index 0 and 1 (i.e. 0:num_img[0]) are considered. The sum of snr_param[0, 0:2] &gt; 8 is checked. If True, then snr_hit = True. </span>
                <span class="c1"># v) Second iteration: snr_threshold=6 and num_img=1. In snr_param, column index 2 (i.e. num_img[0]:num_img[1]) is considered. The sum of snr_param[0, 0:1] &gt; 6 is checked. If True, then snr_hit = True.</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">idx_max</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">snr_th</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">snr_threshold</span><span class="p">):</span>
                    <span class="n">idx_max</span> <span class="o">=</span> <span class="n">idx_max</span> <span class="o">+</span> <span class="n">num_img</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">snr_hit</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">snr_param</span><span class="p">[:,</span><span class="n">j</span><span class="p">:</span><span class="n">idx_max</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">snr_th</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">num_img</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="c1"># select according to time delays</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">idx_max</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># sqrt of the the sum of the squares of the snr of the images</span>
                <span class="n">snr_param</span><span class="p">[</span><span class="n">snr_param</span><span class="o">&lt;</span><span class="n">snr_cut_for_combine_image_snr</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># images with snr below snr_cut_for_combine_image_snr are not considered </span>
                <span class="n">snr_param</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">snr_param</span><span class="p">[:,:</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">num_img</span><span class="p">)]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">snr_param</span> <span class="o">&gt;=</span> <span class="n">snr_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                
        <span class="k">elif</span> <span class="n">detectability_condition</span> <span class="o">==</span> <span class="s2">&quot;pdet&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;pdet_net&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lensed_param</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;optimal_snr_net&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lensed_param</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;optimal_snr_net&#39; or &#39;pdet_net&#39; not in lensed parm dict provided&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating pdet using &#39;optimal_snr_net&#39;...&quot;</span><span class="p">)</span>
                    <span class="c1"># pdet dimension is (size, n_max_images)</span>
                    <span class="n">snr_param</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;optimal_snr_net&quot;</span><span class="p">]</span>
                    <span class="n">snr_param</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">snr_param</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># sort snr in descending order</span>

                    <span class="c1"># column index beyong np.sum(num_img)-1 are not considered</span>
                    <span class="n">pdet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">snr_param</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">num_img</span><span class="p">)))</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">idx_max</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">snr_th</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">snr_threshold</span><span class="p">):</span>
                        <span class="n">idx_max</span> <span class="o">=</span> <span class="n">idx_max</span> <span class="o">+</span> <span class="n">num_img</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">pdet</span><span class="p">[:,</span><span class="n">j</span><span class="p">:</span><span class="n">idx_max</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">snr_th</span> <span class="o">-</span> <span class="n">snr_param</span><span class="p">[:,</span><span class="n">j</span><span class="p">:</span><span class="n">idx_max</span><span class="p">])</span>
                        <span class="n">j</span> <span class="o">=</span> <span class="n">idx_max</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pdet</span> <span class="o">=</span> <span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;pdet_net&quot;</span><span class="p">]</span>
                <span class="c1"># sort pdet in descending order</span>
                <span class="n">pdet</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">-</span><span class="n">pdet</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  
                <span class="c1"># column index beyong np.sum(num_img)-1 are not considered</span>
                <span class="n">pdet</span> <span class="o">=</span> <span class="n">pdet</span><span class="p">[:,:</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">num_img</span><span class="p">)]</span> 
                
            <span class="n">snr_hit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">pdet</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;=</span><span class="n">pdet_threshold</span>

        <span class="k">return</span> <span class="n">snr_hit</span>

<div class="viewcode-block" id="LeR.rate_comparison_with_rate_calculation">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.rate_comparison_with_rate_calculation">[docs]</a>
    <span class="k">def</span> <span class="nf">rate_comparison_with_rate_calculation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">unlensed_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">snr_threshold_unlensed</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="n">output_jsonfile_unlensed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lensed_param</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">snr_threshold_lensed</span><span class="o">=</span><span class="p">[</span><span class="mf">8.0</span><span class="p">,</span><span class="mf">8.0</span><span class="p">],</span>
        <span class="n">num_img</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">combine_image_snr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snr_cut_for_combine_image_snr</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
        <span class="n">output_jsonfile_lensed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">detectability_condition</span><span class="o">=</span><span class="s2">&quot;step_function&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate the unlensed and lensed rate and compare by computing the ratio. This function also stores the parameters of the detectable events in json file. If you use this function, you do not need to call the functions unlensed_rate and lensed_rate separately.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unlensed_param : `dict` or `str`</span>
<span class="sd">            dictionary of GW source parameters or json file name.</span>
<span class="sd">            default unlensed_param = &#39;unlensed_params.json&#39;.</span>
<span class="sd">        snr_threshold_unlensed : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            e.g. snr_threshold_unlensed = 8.</span>
<span class="sd">        output_jsonfile_unlensed : `str`</span>
<span class="sd">            json file name for storing the parameters of the detectable events.</span>
<span class="sd">            default output_jsonfile_unlensed = &#39;unlensed_params_detectable.json&#39;.</span>
<span class="sd">        lensed_param : `dict` or `str`</span>
<span class="sd">            dictionary of GW source parameters or json file name.</span>
<span class="sd">            default lensed_param = &#39;lensed_params.json&#39;.</span>
<span class="sd">        snr_threshold_lensed : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            default snr_threshold_lensed = [8.0,8.0].</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images.</span>
<span class="sd">            default num_img = [1,1]. Together with snr_threshold = [8.0,8.0], it means that two images with snr&gt;8.0. Same condition can also be represented by snr_threshold = 8.0 and num_img = 2.</span>
<span class="sd">        output_jsonfile_lensed : `str`</span>
<span class="sd">            json file name for storing the parameters of the detectable events.</span>
<span class="sd">            default output_jsonfile_lensed = &#39;lensed_params_detectable.json&#39;.</span>
<span class="sd">        nan_to_num : `bool`</span>
<span class="sd">            if True, nan values will be converted to 0.</span>
<span class="sd">            default nan_to_num = True.</span>
<span class="sd">        detectability_condition : `str`</span>
<span class="sd">            detectability condition.</span>
<span class="sd">            default detectability_condition = &#39;step_function&#39;.</span>
<span class="sd">            other options are &#39;pdet&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        rate_ratio : `float`</span>
<span class="sd">            rate ratio.</span>
<span class="sd">        unlensed_param : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters of the detectable events. Refer to :attr:`~unlensed_param` for details.</span>
<span class="sd">        lensed_param : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters of the detectable events. Refer to :attr:`~lensed_param` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; ler.unlensed_cbc_statistics();</span>
<span class="sd">        &gt;&gt;&gt; ler.lensed_cbc_statistics();</span>
<span class="sd">        &gt;&gt;&gt; rate_ratio, unlensed_param, lensed_param = ler.rate_comparison_with_rate_calculation()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call json_file_ler_param and add the results</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>

        <span class="c1"># get unlensed rate</span>
        <span class="n">unlensed_rate</span><span class="p">,</span> <span class="n">unlensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unlensed_rate</span><span class="p">(</span>
            <span class="n">unlensed_param</span><span class="o">=</span><span class="n">unlensed_param</span><span class="p">,</span>
            <span class="n">snr_threshold</span><span class="o">=</span><span class="n">snr_threshold_unlensed</span><span class="p">,</span>
            <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">output_jsonfile_unlensed</span><span class="p">,</span>
            <span class="n">detectability_condition</span><span class="o">=</span><span class="n">detectability_condition</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># get lensed rate</span>
        <span class="n">lensed_rate</span><span class="p">,</span> <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lensed_rate</span><span class="p">(</span>
            <span class="n">lensed_param</span><span class="o">=</span><span class="n">lensed_param</span><span class="p">,</span>
            <span class="n">snr_threshold</span><span class="o">=</span><span class="n">snr_threshold_lensed</span><span class="p">,</span>
            <span class="n">num_img</span><span class="o">=</span><span class="n">num_img</span><span class="p">,</span>
            <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">output_jsonfile_lensed</span><span class="p">,</span>
            <span class="n">nan_to_num</span><span class="o">=</span><span class="n">nan_to_num</span><span class="p">,</span>
            <span class="n">detectability_condition</span><span class="o">=</span><span class="n">detectability_condition</span><span class="p">,</span>
            <span class="n">combine_image_snr</span><span class="o">=</span><span class="n">combine_image_snr</span><span class="p">,</span>
            <span class="n">snr_cut_for_combine_image_snr</span><span class="o">=</span><span class="n">snr_cut_for_combine_image_snr</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># calculate rate ratio</span>
        <span class="n">rate_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_ratio</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">rate_ratio</span><span class="p">,</span> <span class="n">unlensed_param</span><span class="p">,</span> <span class="n">lensed_param</span></div>

     
<div class="viewcode-block" id="LeR.rate_ratio">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.rate_ratio">[docs]</a>
    <span class="k">def</span> <span class="nf">rate_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to calculate and display unlensed and lensed merger rate ratio. It will get the unlensed_rate and lensed_rate from files corresponding to the names included in self.json_file_ler_param. </span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        rate_ratio : `float`</span>
<span class="sd">            rate ratio.</span>

<span class="sd">        Examples</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; ler.unlensed_cbc_statistics();</span>
<span class="sd">        &gt;&gt;&gt; ler.lensed_cbc_statistics();</span>
<span class="sd">        &gt;&gt;&gt; ler.unlensed_rate();</span>
<span class="sd">        &gt;&gt;&gt; ler.lensed_rate();</span>
<span class="sd">        &gt;&gt;&gt; ler.rate_ratio()</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># call json_file_ler_param and add the results</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">unlensed_rate</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;detectable_unlensed_rate_per_year&#39;</span><span class="p">]</span>
            <span class="n">lensed_rate</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;detectable_lensed_rate_per_year&#39;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;detectable_unlensed_rate_per_year or &#39;detectable_lensed_rate_per_year&#39; not found in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s1">&#39;ler_params&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> json file. Exiting...&quot;</span><span class="p">)</span>
        
        <span class="n">rate_ratio</span> <span class="o">=</span> <span class="n">unlensed_rate</span> <span class="o">/</span> <span class="n">lensed_rate</span>
        <span class="c1"># append the results</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rate_ratio&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate_ratio</span>
        <span class="c1"># write the results</span>
        <span class="n">append_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unlensed_rate: </span><span class="si">{</span><span class="n">unlensed_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lensed_rate: </span><span class="si">{</span><span class="n">lensed_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ratio: </span><span class="si">{</span><span class="n">rate_ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">unlensed_rate</span> <span class="o">/</span> <span class="n">lensed_rate</span></div>


<div class="viewcode-block" id="LeR.selecting_n_unlensed_detectable_events">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.selecting_n_unlensed_detectable_events">[docs]</a>
    <span class="k">def</span> <span class="nf">selecting_n_unlensed_detectable_events</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">stopping_criteria</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">relative_diff_percentage</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">number_of_last_batches_to_check</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">snr_threshold</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="n">pdet_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="s2">&quot;n_unlensed_param_detectable.json&quot;</span><span class="p">,</span>
        <span class="n">meta_data_file</span><span class="o">=</span><span class="s2">&quot;meta_unlensed.json&quot;</span><span class="p">,</span>
        <span class="n">detectability_condition</span><span class="o">=</span><span class="s2">&quot;step_function&quot;</span><span class="p">,</span>
        <span class="n">trim_to_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snr_recalculation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snr_threshold_recalculation</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate n unlensed detectable events. This fuction samples the unlensed parameters and save only the detectable events in json file. It also records metadata in the JSON file, which includes the total number of events and the cumulative rate of events. This functionality is particularly useful for generating a fixed or large number of detectable events until the event rates stabilize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : `int`</span>
<span class="sd">            number of samples to be selected.</span>
<span class="sd">            default size = 100.</span>
<span class="sd">        batch_size : `int`</span>
<span class="sd">            batch size for sampling.</span>
<span class="sd">            default batch_size = 50000.</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            e.g. snr_threshold = 8.</span>
<span class="sd">        pdet_threshold : `float`</span>
<span class="sd">            threshold for detection probability.</span>
<span class="sd">            default pdet_threshold = 0.5.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            resume = False (default) or True.</span>
<span class="sd">            if True, the function will resume from the last batch.</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters of the detectable events.</span>
<span class="sd">            default output_jsonfile = &#39;n_unlensed_param_detectable.json&#39;.</span>
<span class="sd">        meta_data_file : `str`</span>
<span class="sd">            json file name for storing the metadata.</span>
<span class="sd">            default meta_data_file = &#39;meta_unlensed.json&#39;.</span>
<span class="sd">        detectability_condition : `str`</span>
<span class="sd">            detectability condition.</span>
<span class="sd">            default detectability_condition = &#39;step_function&#39;.</span>
<span class="sd">            other options are &#39;pdet&#39;.</span>
<span class="sd">        trim_to_size : `bool`</span>
<span class="sd">            if True, the final result will be trimmed to size.</span>
<span class="sd">            default trim_to_size = True.</span>
<span class="sd">        snr_recalculation : `bool`</span>
<span class="sd">            if True, the SNR of centain events (snr&gt;snr_threshold_recalculation)will be recalculate with &#39;inner-product&#39; method. This is useful when the snr is calculated with &#39;ann&#39; method of `gwsnr`.</span>
<span class="sd">            default snr_recalculation = False.</span>
<span class="sd">        snr_threshold_recalculation : `list`</span>
<span class="sd">            lower and upper threshold for recalculation of detection signal to noise ratio.</span>
<span class="sd">            default snr_threshold_recalculation = [4, 12].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        param_final : `dict`</span>
<span class="sd">            dictionary of unlensed GW source parameters of the detectable events. Refer to :attr:`~unlensed_param` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; unlensed_param = ler.selecting_n_unlensed_detectable_events(size=100)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initial setup</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">buffer_file</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_setup_for_n_event_selection</span><span class="p">(</span><span class="n">meta_data_file</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">resume</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>

        <span class="c1"># loop until n samples are collected</span>
        <span class="n">continue_condition</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">continue_condition</span><span class="p">:</span>
            <span class="c1"># disable print statements</span>
            <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict_buffer</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># this is used to store the sampled unlensed_param in batches when running the sampling_routine</span>
                <span class="n">unlensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unlensed_sampling_routine</span><span class="p">(</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">buffer_file</span><span class="p">,</span> <span class="n">save_batch</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">resume</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

            <span class="n">total_events_in_this_iteration</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>
            <span class="c1"># below is use when the snr is calculated with &#39;ann&#39; method of `gwsnr`</span>
            <span class="k">if</span> <span class="n">snr_recalculation</span><span class="p">:</span>
                <span class="c1"># select only above centain snr threshold</span>
                <span class="n">unlensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recalculate_snr_unlensed</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">,</span> <span class="n">snr_threshold_recalculation</span><span class="p">)</span>

            <span class="c1"># find index of detectable events</span>
            <span class="n">idx_detectable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_detectable_index_unlensed</span><span class="p">(</span><span class="n">unlensed_param</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="p">)</span>

            <span class="c1"># store all params in json file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_detectable_params</span><span class="p">(</span><span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">unlensed_param</span><span class="p">,</span> <span class="n">idx_detectable</span><span class="p">,</span> <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;n_unlensed_detectable_events&quot;</span><span class="p">,</span> <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">idx_detectable</span><span class="p">)</span>
            <span class="n">events_total</span> <span class="o">+=</span> <span class="n">total_events_in_this_iteration</span>              
            <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># bookmark</span>
            <span class="n">buffer_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_meta_data</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">total_rate</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stopping_criteria</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">total_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">buffer_dict</span><span class="p">[</span><span class="s1">&#39;total_rate&#39;</span><span class="p">])</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">stopping_criteria</span><span class="p">[</span><span class="s1">&#39;relative_diff_percentage&#39;</span><span class="p">]</span>
                <span class="n">num_a</span> <span class="o">=</span> <span class="n">stopping_criteria</span><span class="p">[</span><span class="s1">&#39;number_of_last_batches_to_check&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_rates</span><span class="p">)</span><span class="o">&gt;</span><span class="n">num_a</span><span class="p">:</span>
                    <span class="n">num_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">num_a</span><span class="p">))</span>
                    <span class="c1"># num_b = int(num_a)</span>
                    <span class="n">percentage_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">total_rates</span><span class="p">[</span><span class="n">num_a</span><span class="p">:]</span><span class="o">-</span><span class="n">total_rates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">total_rates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="mi">100</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;percentage difference for the last </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">num_a</span><span class="p">)</span><span class="si">}</span><span class="s2"> batches = </span><span class="si">{</span><span class="n">percentage_diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">percentage_diff</span><span class="o">&gt;</span><span class="n">limit</span><span class="p">):</span>
                        <span class="n">continue_condition</span> <span class="o">&amp;=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">rf</span><span class="s2">&quot;stopping criteria of rate relative difference of </span><span class="si">{</span><span class="n">limit</span><span class="si">}</span><span class="s2">% reached. If you want to collect more events, reduce stopping_criteria[&#39;relative_diff_percentage&#39;] or put stopping_criteria=None.&quot;</span><span class="p">)</span>
                        <span class="n">continue_condition</span> <span class="o">&amp;=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">size</span><span class="p">:</span>
                    <span class="n">continue_condition</span> <span class="o">|=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">rf</span><span class="s2">&quot;Given size=</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2"> reached&quot;</span><span class="p">)</span>
                    <span class="n">continue_condition</span> <span class="o">|=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="n">stopping_criteria</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">continue_condition</span> <span class="o">&amp;=</span> <span class="kc">False</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;stored detectable unlensed params in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;stored meta data in </span><span class="si">{</span><span class="n">meta_data_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">trim_to_size</span><span class="p">:</span>
            <span class="n">param_final</span><span class="p">,</span> <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim_results_to_size</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>

        <span class="c1"># call self.json_file_names[&quot;ler_param&quot;] and for adding the final results</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>
        <span class="c1"># write the results</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_unlensed_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectability_condition_unlensed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectability_condition</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_unlensed_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;total_rate&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectability_condition_unlensed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectability_condition</span>

        <span class="n">append_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">param_final</span></div>

    
<div class="viewcode-block" id="LeR.selecting_n_lensed_detectable_events">
<a class="viewcode-back" href="../../../autoapi/ler/rates/ler/index.html#ler.rates.LeR.selecting_n_lensed_detectable_events">[docs]</a>
    <span class="k">def</span> <span class="nf">selecting_n_lensed_detectable_events</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
        <span class="n">stopping_criteria</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">relative_diff_percentage</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
            <span class="n">number_of_last_batches_to_check</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">batch_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">snr_threshold</span><span class="o">=</span><span class="p">[</span><span class="mf">8.0</span><span class="p">,</span><span class="mf">8.0</span><span class="p">],</span>
        <span class="n">pdet_threshold</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
        <span class="n">num_img</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">combine_image_snr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snr_cut_for_combine_image_snr</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
        <span class="n">resume</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">detectability_condition</span><span class="o">=</span><span class="s2">&quot;step_function&quot;</span><span class="p">,</span>
        <span class="n">output_jsonfile</span><span class="o">=</span><span class="s2">&quot;n_lensed_params_detectable.json&quot;</span><span class="p">,</span>
        <span class="n">meta_data_file</span><span class="o">=</span><span class="s2">&quot;meta_lensed.json&quot;</span><span class="p">,</span>
        <span class="n">trim_to_size</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">nan_to_num</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snr_recalculation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snr_threshold_recalculation</span><span class="o">=</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">]],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function to generate n lensed detectable events. This fuction only samples the lensed parameters and save only the detectable events in json file. It also records metadata in the JSON file, which includes the total number of events and the cumulative rate of events. This functionality is particularly useful for generating a fixed or large number of detectable events until the event rates stabilize.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : `int`</span>
<span class="sd">            number of samples.</span>
<span class="sd">            default size = 100.</span>
<span class="sd">        batch_size : `int`</span>
<span class="sd">            batch size for sampling.</span>
<span class="sd">            default batch_size = 50000.</span>
<span class="sd">        snr_threshold : `float`</span>
<span class="sd">            threshold for detection signal to noise ratio.</span>
<span class="sd">            default snr_threshold = [8.0,8.0].</span>
<span class="sd">        pdet_threshold : `float`</span>
<span class="sd">            threshold for detection probability.</span>
<span class="sd">            default pdet_threshold = 0.5.</span>
<span class="sd">        num_img : `int`</span>
<span class="sd">            number of images.</span>
<span class="sd">            default num_img = [1,1]. Together with snr_threshold = [8.0,8.0], it means that two images with snr&gt;8.0. Same condition can also be represented by snr_threshold = 8.0 and num_img = 2.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            resume = False (default) or True.</span>
<span class="sd">            if True, it appends the new samples to the existing json file.</span>
<span class="sd">        detectability_condition : `str`</span>
<span class="sd">            detectability condition.</span>
<span class="sd">            default detectability_condition = &#39;step_function&#39;.</span>
<span class="sd">            other options are &#39;pdet&#39;.</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters of the detectable events.</span>
<span class="sd">            default output_jsonfile = &#39;n_lensed_params_detectable.json&#39;.</span>
<span class="sd">        meta_data_file : `str`</span>
<span class="sd">            json file name for storing the metadata.</span>
<span class="sd">            default meta_data_file = &#39;meta_lensed.json&#39;.</span>
<span class="sd">        trim_to_size : `bool`</span>
<span class="sd">            if True, the final result will be trimmed to size.</span>
<span class="sd">            default trim_to_size = True.</span>
<span class="sd">        nan_to_num : `bool`</span>
<span class="sd">            if True, nan values will be converted to 0.</span>
<span class="sd">            default nan_to_num = False.</span>
<span class="sd">        snr_recalculation : `bool`</span>
<span class="sd">            if True, the SNR of centain events (snr&gt;snr_threshold_recalculation)will be recalculate with &#39;inner-product&#39; method. This is useful when the snr is calculated with &#39;ann&#39; method of `gwsnr`.    </span>
<span class="sd">            default snr_recalculation = False.</span>
<span class="sd">        snr_threshold_recalculation : `list`</span>
<span class="sd">            lower and upper threshold for recalculation of detection signal to noise ratio.</span>
<span class="sd">            default snr_threshold_recalculation = [[4,4], [12,12]].</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        param_final : `dict`</span>
<span class="sd">            dictionary of lensed GW source parameters of the detectable events. Refer to :attr:`~lensed_param` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        ----------</span>
<span class="sd">        &gt;&gt;&gt; from ler.rates import LeR</span>
<span class="sd">        &gt;&gt;&gt; ler = LeR()</span>
<span class="sd">        &gt;&gt;&gt; lensed_param = ler.selecting_n_lensed_detectable_events(size=100)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initial setup</span>
        <span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">buffer_file</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_setup_for_n_event_selection</span><span class="p">(</span><span class="n">meta_data_file</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">resume</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">)</span>

        <span class="c1"># re-analyse the provided snr_threshold and num_img</span>
        <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">num_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_snr_threshold_lensed</span><span class="p">(</span><span class="n">snr_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">)</span>

        <span class="n">continue_condition</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">continue_condition</span><span class="p">:</span>
            <span class="c1"># disable print statements</span>
            <span class="k">with</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">redirect_stdout</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dict_buffer</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># this is used to store the sampled lensed_param in batches when running the sampling_routine</span>
                <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lensed_sampling_routine</span><span class="p">(</span>
                    <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="o">=</span><span class="n">buffer_file</span><span class="p">,</span> <span class="n">resume</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>  <span class="c1"># Dimensions are (size, n_max_images)</span>

            <span class="n">total_events_in_this_iteration</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>

            <span class="c1"># Below code ensures that the snr is recalculated for the detectable events with inner product</span>
            <span class="c1"># The code is use when the snr is calculated with &#39;ann&#39; method of `gwsnr`</span>
            <span class="k">if</span> <span class="n">snr_recalculation</span><span class="p">:</span>
                <span class="n">lensed_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recalculate_snr_lensed</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">,</span> <span class="n">snr_threshold_recalculation</span><span class="p">,</span> <span class="n">num_img</span><span class="p">,</span> <span class="n">total_events_in_this_iteration</span><span class="p">)</span>

            <span class="n">snr_hit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_detectable_index_lensed</span><span class="p">(</span><span class="n">lensed_param</span><span class="p">,</span> <span class="n">snr_threshold</span><span class="p">,</span> <span class="n">pdet_threshold</span><span class="p">,</span> <span class="n">num_img</span><span class="p">,</span> <span class="n">detectability_condition</span><span class="p">,</span> <span class="n">combine_image_snr</span><span class="o">=</span><span class="n">combine_image_snr</span><span class="p">,</span> <span class="n">snr_cut_for_combine_image_snr</span><span class="o">=</span><span class="n">snr_cut_for_combine_image_snr</span><span class="p">)</span>
                    
            <span class="c1"># store all params in json file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_detectable_params</span><span class="p">(</span><span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">lensed_param</span><span class="p">,</span> <span class="n">snr_hit</span><span class="p">,</span> <span class="n">key_file_name</span><span class="o">=</span><span class="s2">&quot;n_lensed_detectable_events&quot;</span><span class="p">,</span> <span class="n">nan_to_num</span><span class="o">=</span><span class="n">nan_to_num</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">replace_jsonfile</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">n</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">snr_hit</span><span class="p">)</span>
            <span class="n">events_total</span> <span class="o">+=</span> <span class="n">total_events_in_this_iteration</span>
            <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># save meta data</span>
            <span class="n">buffer_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_append_meta_data</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">total_rate</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stopping_criteria</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">total_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">buffer_dict</span><span class="p">[</span><span class="s1">&#39;total_rate&#39;</span><span class="p">])</span>
                <span class="n">limit</span> <span class="o">=</span> <span class="n">stopping_criteria</span><span class="p">[</span><span class="s1">&#39;relative_diff_percentage&#39;</span><span class="p">]</span>
                <span class="n">num_a</span> <span class="o">=</span> <span class="n">stopping_criteria</span><span class="p">[</span><span class="s1">&#39;number_of_last_batches_to_check&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">total_rates</span><span class="p">)</span><span class="o">&gt;</span><span class="n">num_a</span><span class="p">:</span>
                    <span class="n">num_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="n">num_a</span><span class="p">))</span>
                    <span class="c1"># num_b = int(num_a)</span>
                    <span class="n">percentage_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">total_rates</span><span class="p">[</span><span class="n">num_a</span><span class="p">:]</span><span class="o">-</span><span class="n">total_rates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">total_rates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="mi">100</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;percentage difference for the last </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">num_a</span><span class="p">)</span><span class="si">}</span><span class="s2"> batches = </span><span class="si">{</span><span class="n">percentage_diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">percentage_diff</span><span class="o">&gt;</span><span class="n">limit</span><span class="p">):</span>
                        <span class="n">continue_condition</span> <span class="o">&amp;=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">rf</span><span class="s2">&quot;stopping criteria of rate relative difference of </span><span class="si">{</span><span class="n">limit</span><span class="si">}</span><span class="s2">% reached. If you want to collect more events, reduce stopping_criteria[&#39;relative_diff_percentage&#39;]&quot;</span><span class="p">)</span>
                        <span class="n">continue_condition</span> <span class="o">&amp;=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">size</span><span class="p">:</span>
                    <span class="n">continue_condition</span> <span class="o">|=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">rf</span><span class="s2">&quot;Given size=</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2"> reached&quot;</span><span class="p">)</span>
                    <span class="n">continue_condition</span> <span class="o">|=</span> <span class="kc">False</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;storing detectable lensed params in </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;storing meta data in </span><span class="si">{</span><span class="n">meta_data_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">trim_to_size</span><span class="p">:</span>
            <span class="n">param_final</span><span class="p">,</span> <span class="n">total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trim_results_to_size</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;lensed&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>

        <span class="c1"># call self.json_file_names[&quot;ler_param&quot;] and for adding the final results</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">])</span>
        <span class="c1"># write the results</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_lensed_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_rate</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectability_condition_lensed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectability_condition</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">meta</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectable_lensed_rate_per_year&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta</span><span class="p">[</span><span class="s2">&quot;total_rate&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s2">&quot;detectability_condition_lensed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detectability_condition</span>
        <span class="n">buffer_dict</span> <span class="o">=</span> <span class="n">append_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">json_file_names</span><span class="p">[</span><span class="s2">&quot;ler_params&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">param_final</span></div>


    <span class="k">def</span> <span class="nf">_initial_setup_for_n_event_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_data_file</span><span class="p">,</span> <span class="n">output_jsonfile</span><span class="p">,</span> <span class="n">resume</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper function for selecting_n_unlensed_detectable_events and selecting_n_lensed_detectable_events functions. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_data_file : `str`</span>
<span class="sd">            json file name for storing the metadata.</span>
<span class="sd">        output_jsonfile : `str`</span>
<span class="sd">            json file name for storing the parameters of the detectable events.</span>
<span class="sd">        resume : `bool`</span>
<span class="sd">            resume = False (default) or True.</span>
<span class="sd">            if True, the function will resume from the last batch.</span>
<span class="sd">        batch_size : `int`</span>
<span class="sd">            batch size for sampling.</span>
<span class="sd">            default batch_size = 50000.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        n : `int`</span>
<span class="sd">            iterator.</span>
<span class="sd">        events_total : `int`</span>
<span class="sd">            total number of events.</span>
<span class="sd">        output_path : `str`</span>
<span class="sd">            path to the output json file.</span>
<span class="sd">        meta_data_path : `str`</span>
<span class="sd">            path to the metadata json file.</span>
<span class="sd">        buffer_file : `str`</span>
<span class="sd">            path to the buffer json file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">meta_data_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">meta_data_file</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ler_directory</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">output_jsonfile</span>
        <span class="k">if</span> <span class="n">meta_data_path</span><span class="o">==</span><span class="n">output_path</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;meta_data_file and output_jsonfile cannot be same.&quot;</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">resume</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># iterator</span>
            <span class="n">events_total</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># the following file will be removed if it exists</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;removing </span><span class="si">{</span><span class="n">output_path</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">meta_data_path</span><span class="si">}</span><span class="s2"> if they exist&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_path</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># get sample size as size from json file</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_path</span><span class="p">):</span>
                <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_final</span><span class="p">[</span><span class="s2">&quot;zs&quot;</span><span class="p">])</span>
                <span class="n">events_total</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)[</span><span class="s2">&quot;events_total&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">param_final</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">events_total</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">buffer_file</span> <span class="o">=</span> <span class="s2">&quot;params_buffer.json&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of detectable events = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">buffer_file</span><span class="p">,</span> <span class="n">batch_size</span>

    <span class="k">def</span> <span class="nf">_trim_results_to_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">output_path</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="s2">&quot;unlensed&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function of &#39;selecting_n_unlensed_detectable_events&#39; and &#39;selecting_n_lensed_detectable_events&#39; functions. Trims the data in the output file to the specified size and updates the metadata accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        size : `int`</span>
<span class="sd">            number of samples to be selected.</span>
<span class="sd">        output_path : `str`</span>
<span class="sd">            path to the output json file.</span>
<span class="sd">        meta_data_path : `str`</span>
<span class="sd">            path to the metadata json file.</span>
<span class="sd">        param_type : `str`</span>
<span class="sd">            type of parameters.</span>
<span class="sd">            default param_type = &quot;unlensed&quot;.</span>
<span class="sd">            other options are &quot;lensed&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        param_final : `dict`</span>
<span class="sd">            dictionary of GW source parameters of the detectable events. Refer to :attr:`~unlensed_param` or :attr:`~lensed_param` for details.</span>
<span class="sd">        new_total_rate : `float`</span>
<span class="sd">            total rate (Mpc^-3 yr^-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> trmming final result to size=</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">param_final</span> <span class="o">=</span> <span class="n">get_param_from_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="c1"># randomly select size number of samples</span>
        <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">param_final</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">len_</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># trim the final param dictionary, randomly, without repeating</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">param_final</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">param_final</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># change meta data</span>
        <span class="n">meta_data</span> <span class="o">=</span> <span class="n">load_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">)</span>
        <span class="n">old_events_total</span> <span class="o">=</span> <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;events_total&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">old_detectable_events</span> <span class="o">=</span> <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;detectable_events&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># adjust the meta data</span>
        <span class="c1"># following is to keep rate the same</span>
        <span class="n">new_events_total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">size</span><span class="o">*</span><span class="n">old_events_total</span><span class="o">/</span><span class="n">old_detectable_events</span><span class="p">)</span>
        <span class="n">new_total_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate_function</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">new_events_total</span><span class="p">,</span> <span class="n">param_type</span><span class="o">=</span><span class="n">param_type</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;events_total&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_events_total</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;detectable_events&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
        <span class="n">meta_data</span><span class="p">[</span><span class="s2">&quot;total_rate&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_total_rate</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of detectable events = &quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total number of events = &quot;</span><span class="p">,</span> <span class="n">new_events_total</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total </span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2"> event rate (yr^-1): </span><span class="si">{</span><span class="n">new_total_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># save the meta data</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># save the final param dictionary</span>
        <span class="n">append_json</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">param_final</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">param_final</span><span class="p">,</span> <span class="n">new_total_rate</span>

    <span class="k">def</span> <span class="nf">_append_meta_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meta_data_path</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">events_total</span><span class="p">,</span> <span class="n">total_rate</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function for appending meta data json file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meta_data_path : `str`</span>
<span class="sd">            path to the metadata json file.</span>
<span class="sd">        n : `int`</span>
<span class="sd">            iterator.</span>
<span class="sd">        events_total : `int`</span>
<span class="sd">            total number of events.</span>
<span class="sd">        total_rate : `float`</span>
<span class="sd">            total rate (Mpc^-3 yr^-1).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># save meta data</span>
        <span class="n">meta_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">events_total</span><span class="o">=</span><span class="p">[</span><span class="n">events_total</span><span class="p">],</span> <span class="n">detectable_events</span><span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)],</span> <span class="n">total_rate</span><span class="o">=</span><span class="p">[</span><span class="n">total_rate</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dict_</span> <span class="o">=</span> <span class="n">append_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">dict_</span> <span class="o">=</span> <span class="n">append_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dict_</span> <span class="o">=</span> <span class="n">append_json</span><span class="p">(</span><span class="n">meta_data_path</span><span class="p">,</span> <span class="n">meta_data</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;collected number of detectable events = &quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;total number of events = &quot;</span><span class="p">,</span> <span class="n">events_total</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;total rate (yr^-1): </span><span class="si">{</span><span class="n">total_rate</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dict_</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Phurailatpam Hemantakumar.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>