<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Binary Black Hole Precession (Final Camera View)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #ffffff; }
        
        #info {
            position: absolute; top: 10px; width: 100%; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; align-items: center;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border: 1px solid #ddd;
            text-align: center;
        }

        h3 { margin: 0 0 5px 0; color: #333; font-size: 16px; }
        p { margin: 2px 0; font-size: 13px; color: #555; }

        .label {
            font-family: 'Consolas', monospace;
            font-weight: bold;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #ccc;
            position: absolute;
            pointer-events: none;
            white-space: nowrap;
        }
        
        .c-green { color: #2e7d32; }
        .c-purple { color: #7b1fa2; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
</head>
<body>

    <div id="info">
        <div class="panel">
            <h3>Coordinate Systems</h3>
            <p><b class="c-purple">Purple plane</b> = J-coordinate</p>
            <p><b class="c-green">Green plane</b> = L-coordinate</p>
        </div>
    </div>

    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        
        // --- UPDATED CAMERA POSITION FROM SCREENSHOT ---
        camera.position.set(-2.8, 10.5, 17.3);
        camera.up.set(0, 0, 1);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dl = new THREE.DirectionalLight(0xffffff, 0.5);
        dl.position.set(10, -10, 20);
        scene.add(dl);

        // --- J-Frame Elements ---
        const gridJ = new THREE.PolarGridHelper(15, 8, 8, 64, 0xba68c8, 0xba68c8);
        gridJ.rotation.x = Math.PI/2;
        gridJ.material.transparent = true;
        gridJ.material.opacity = 0.15;
        scene.add(gridJ);

        const arrowJ = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(), 6, 0x7b1fa2, 0.5, 0.3);
        scene.add(arrowJ);

        const refArrowLen = 5.0;
        const refArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), refArrowLen, 0x808080, 0.5, 0.4);
        const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(refArrowLen - 0.5,0,0)]);
        const lineMat = new THREE.LineBasicMaterial({ color: 0x808080, linewidth: 3 });
        const refShaft = new THREE.Line(lineGeo, lineMat);
        scene.add(refArrow);
        scene.add(refShaft);

        // --- L Projection Visuals ---
        
        // 1. Arrow Head (Solid Green)
        const projLArrow = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(), 1, 0x2e7d32, 0.4, 0.3);
        scene.add(projLArrow);
        
        // 2. Solid Shaft
        const projShaft = new THREE.Line(
            new THREE.BufferGeometry(), 
            new THREE.LineBasicMaterial({ color: 0x2e7d32, linewidth: 2 })
        );
        scene.add(projShaft);

        // 3. Extended Line (Faint Dashed Green)
        const extProjMat = new THREE.LineDashedMaterial({ 
            color: 0x2e7d32, 
            dashSize: 0.2, 
            gapSize: 0.3, 
            transparent: true, 
            opacity: 0.4 
        });
        const extProjLine = new THREE.Line(new THREE.BufferGeometry(), extProjMat);
        scene.add(extProjLine);

        const jlArcLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x7b1fa2, linewidth: 3 }));
        scene.add(jlArcLine);

        // --- Cone ---
        const coneGroup = new THREE.Group();
        scene.add(coneGroup);
        const coneGeo = new THREE.ConeGeometry(1, 1, 64, 1, true);
        coneGeo.translate(0, -0.5, 0); 
        coneGeo.rotateX(-Math.PI/2);   
        const coneMat = new THREE.MeshBasicMaterial({ color: 0xba68c8, transparent: true, opacity: 0.15, side: THREE.DoubleSide, depthWrite: false });
        const coneMesh = new THREE.Mesh(coneGeo, coneMat);
        coneGroup.add(coneMesh);

        // --- L-Frame ---
        const lContainer = new THREE.Group();
        scene.add(lContainer);

        const gridL = new THREE.PolarGridHelper(10, 8, 8, 64, 0x4caf50, 0xe8f5e9);
        gridL.rotation.x = Math.PI/2;
        gridL.material.transparent = true;
        gridL.material.opacity = 0.6;
        lContainer.add(gridL);

        const L_MAG = 5.0;
        const arrowL = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(), L_MAG, 0x2e7d32, 0.5, 0.3);
        lContainer.add(arrowL);

        // --- Labels ---
        function createLabel(text, color) {
            const el = document.createElement('div');
            el.className = 'label';
            el.innerHTML = text;
            if(color) el.style.color = color;
            document.body.appendChild(el);
            return el;
        }

        const lblJ = createLabel("J", "#7b1fa2");
        const lblL = createLabel("L", "#2e7d32");
        const lblRef = createLabel("φ_ref", "#808080");
        const lblPhiJL = createLabel("φJL", "#7b1fa2");
        const lblPhi12 = createLabel("φ12", "#f57c00");
        const lblProjL = createLabel("Proj(L)", "#2e7d32");

        function updateLabel(elem, pos, text) {
            if(text) elem.innerHTML = text;
            const vec = pos.clone().project(camera);
            if (vec.z > 1) { elem.style.display = 'none'; return; }
            elem.style.display = 'block';
            elem.style.left = ((vec.x * .5 + .5) * window.innerWidth) + 'px';
            elem.style.top = ((-(vec.y * .5) + .5) * window.innerHeight) + 'px';
        }

        // --- Black Holes ---
        class BlackHole {
            constructor(id, colorHex, labelColor) {
                this.id = id;
                this.group = new THREE.Group();
                lContainer.add(this.group); 

                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.8, 32, 32), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                this.group.add(mesh);
                this.mesh = mesh;

                this.arrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(), 1, colorHex, 0.4, 0.2);
                this.group.add(this.arrow);

                const localAxisLen = 3.5;
                const laGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,localAxisLen)]);
                const laMat = new THREE.LineDashedMaterial({ color: 0xaaaaaa, dashSize: 0.3, gapSize: 0.2, scale: 1 });
                const localAxis = new THREE.Line(laGeo, laMat);
                localAxis.computeLineDistances();
                this.group.add(localAxis);

                this.thetaArc = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: colorHex }));
                this.group.add(this.thetaArc);

                this.lbl = createLabel(`BH${id}`, labelColor);
                this.lblTheta = createLabel("", labelColor);
            }

            update(mass, spinMag, theta, phi, r) {
                const s = Math.pow(mass, 1/3) * 0.15;
                this.mesh.scale.set(s,s,s);
                const pos = new THREE.Vector3(this.id===1?r:-r, 0, 0);
                this.group.position.copy(pos);

                const thRad = THREE.MathUtils.degToRad(theta);
                const phiRad = THREE.MathUtils.degToRad(phi);
                
                const sx = spinMag * Math.sin(thRad) * Math.cos(phiRad);
                const sy = spinMag * Math.sin(thRad) * Math.sin(phiRad);
                const sz = spinMag * Math.cos(thRad);
                const spinVec = new THREE.Vector3(sx, sy, sz);

                const len = 1.5 + spinMag * 2.5;
                this.arrow.setDirection(spinVec.clone().normalize());
                this.arrow.setLength(len, 0.4, 0.2);

                const curve = new THREE.EllipseCurve(0,0, 1.2, 1.2, Math.PI/2, Math.PI/2 - thRad, true, 0);
                this.thetaArc.geometry.dispose();
                this.thetaArc.geometry = new THREE.BufferGeometry().setFromPoints(curve.getPoints(16));
                this.thetaArc.rotation.set(Math.PI/2, phiRad, 0);

                const worldPos = pos.clone().applyMatrix4(lContainer.matrixWorld);
                updateLabel(this.lbl, worldPos.clone().add(new THREE.Vector3(0,0,-1)));
                updateLabel(this.lblTheta, worldPos.clone().add(new THREE.Vector3(0,0,1.5)), `θ${this.id}: ${theta.toFixed(1)}°`);

                return spinVec;
            }
        }

        const bh1 = new BlackHole(1, 0xd32f2f, "#d32f2f");
        const bh2 = new BlackHole(2, 0x1976d2, "#1976d2");
        
        // --- Params ---
        const params = {
            sep: 8.0,
            phiJL: 25.0,
            m1: 30, a1: 0.8, theta1: 143.0, phi1: 30.0,
            m2: 20, a2: 0.9, theta2: 82.0, phi2: 150.0
        };

        const gui = new dat.GUI({ width: 300 });
        gui.add(params, 'sep', 5, 12).name('Separation');
        gui.add(params, 'phiJL', 0, 360).name('Precession (φJL)');
        
        const f1 = gui.addFolder('BH 1 (Red)');
        f1.add(params, 'm1', 5, 50);
        f1.add(params, 'a1', 0, 1, 0.01);
        f1.add(params, 'theta1', 0, 180);
        f1.add(params, 'phi1', 0, 360);
        f1.open();

        const f2 = gui.addFolder('BH 2 (Blue)');
        f2.add(params, 'm2', 5, 50);
        f2.add(params, 'a2', 0, 1, 0.01);
        f2.add(params, 'theta2', 0, 180);
        f2.add(params, 'phi2', 0, 360);
        f2.open();

        const phi12Arc = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xf57c00, linewidth: 3 }));
        lContainer.add(phi12Arc);
        const projS1 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(), 3, 0xd32f2f, 0.3, 0.2);
        const projS2 = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(), 3, 0x1976d2, 0.3, 0.2);
        lContainer.add(projS1); 
        lContainer.add(projS2);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const M = params.m1 + params.m2;
            const r1 = params.sep * (params.m2 / M);
            const r2 = params.sep * (params.m1 / M);

            const S1_local = bh1.update(params.m1, params.a1, params.theta1, params.phi1, r1);
            const S2_local = bh2.update(params.m2, params.a2, params.theta2, params.phi2, r2);

            const L_vec_local = new THREE.Vector3(0, 0, L_MAG);
            const J_local = L_vec_local.clone().add(S1_local).add(S2_local);
            
            const up = new THREE.Vector3(0,0,1);
            const qAlignJ = new THREE.Quaternion().setFromUnitVectors(J_local.clone().normalize(), up);
            lContainer.quaternion.copy(qAlignJ);
            
            const L_world_dir = new THREE.Vector3(0,0,1).applyQuaternion(qAlignJ);
            const currentPhi = Math.atan2(L_world_dir.y, L_world_dir.x);
            const targetPhi = THREE.MathUtils.degToRad(params.phiJL);
            const deltaPhi = targetPhi - currentPhi;
            
            const qRotateZ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), deltaPhi);
            lContainer.quaternion.premultiply(qRotateZ); 

            const J_mag = J_local.length();
            arrowJ.setLength(J_mag, 0.4, 0.3);

            // Update Cone
            const height = L_MAG * L_world_dir.z; 
            const radius = Math.sqrt(L_MAG*L_MAG - height*height);
            coneMesh.scale.set(radius, radius, height);

            // --- Projection Logic ---
            const L_final_dir = new THREE.Vector3(0,0,1).applyMatrix4(lContainer.matrixWorld).normalize();
            const L_proj_len = Math.sqrt(L_final_dir.x*L_final_dir.x + L_final_dir.y*L_final_dir.y) * 4.0; 
            const L_proj_dir = new THREE.Vector3(L_final_dir.x, L_final_dir.y, 0).normalize();
            
            // 1. Arrow Head
            projLArrow.setDirection(L_proj_dir);
            projLArrow.setLength(L_proj_len, 0.3, 0.2);
            
            // 2. Solid Shaft
            const shaftEnd = L_proj_dir.clone().multiplyScalar(L_proj_len - 0.3);
            projShaft.geometry.setFromPoints([new THREE.Vector3(0,0,0), shaftEnd]);
            
            // 3. Faint Extended Line
            const extStart = L_proj_dir.clone().multiplyScalar(L_proj_len + 0.5);
            const extEnd = L_proj_dir.clone().multiplyScalar(10);
            extProjLine.geometry.setFromPoints([extStart, extEnd]);
            extProjLine.computeLineDistances();

            // JL Arc
            const jlCurve = new THREE.EllipseCurve(0,0, 3.0, 3.0, 0, targetPhi, false, 0);
            jlArcLine.geometry.dispose();
            jlArcLine.geometry = new THREE.BufferGeometry().setFromPoints(jlCurve.getPoints(30));
            jlArcLine.position.z = 0.05;

            // Phi 12
            const p1 = THREE.MathUtils.degToRad(params.phi1);
            const p2 = THREE.MathUtils.degToRad(params.phi2);
            projS1.setDirection(new THREE.Vector3(Math.cos(p1), Math.sin(p1), 0));
            projS2.setDirection(new THREE.Vector3(Math.cos(p2), Math.sin(p2), 0));
            let p12 = p2 - p1; if(p12<0) p12+=Math.PI*2;
            const c12 = new THREE.EllipseCurve(0,0, 2.5, 2.5, p1, p1+p12, false, 0);
            phi12Arc.geometry.dispose();
            phi12Arc.geometry = new THREE.BufferGeometry().setFromPoints(c12.getPoints(20));

            // Labels
            updateLabel(lblJ, new THREE.Vector3(0,0,J_mag + 0.5));
            const L_tip_world = new THREE.Vector3(0,0,L_MAG).applyMatrix4(lContainer.matrixWorld);
            updateLabel(lblL, L_tip_world.add(new THREE.Vector3(0,0,0.5)));

            updateLabel(lblRef, new THREE.Vector3(5.5,0,0));
            
            const projTip = L_proj_dir.clone().multiplyScalar(L_proj_len + 0.5);
            updateLabel(lblProjL, projTip);

            const lblJLPos = new THREE.Vector3(Math.cos(targetPhi/2)*3.2, Math.sin(targetPhi/2)*3.2, 0);
            updateLabel(lblPhiJL, lblJLPos, `φJL: ${params.phiJL.toFixed(1)}°`);

            const lbl12Local = new THREE.Vector3(Math.cos(p1+p12/2)*3, Math.sin(p1+p12/2)*3, 0);
            const lbl12World = lbl12Local.applyMatrix4(lContainer.matrixWorld);
            updateLabel(lblPhi12, lbl12World, `φ12: ${THREE.MathUtils.radToDeg(p12).toFixed(1)}°`);

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>